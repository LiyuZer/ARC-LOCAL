{"b548a754": {"instruction": "1. Identify the smallest non-background (nonzero) rectangle in the grid. This is the 'core' object. In the test input, it is the 4x3 block of '4' and '6' near the bottom.\n2. Detect any row or column containing a special marker (here, the value 8). Treat the location of '8' as the desired \"center\" or focal point for the expanded object.\n3. Expand the core object symmetrically so that its outer boundary (formerly '6' in this test input) fills outward, matching the grid's pattern for outer boundaries, until it reaches the same rows and columns as the current set of outer boundary values. Similarly, for the inner content ('4'), expand them accordingly, filling the area inside the new boundary.\n4. Overlay the expanded object so that its center aligns with the location of the marker (value '8'), replacing the marker if necessary.\n5. Fill in all interior rows and columns inside the boundary with the appropriate inner value, based on the pattern of the original core (e.g., fill with '4' inside the surrounding '6').\n6. All other cells remain unchanged (usually background zero).", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 4, 4, 4, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0]]}, "b5bb5719": {"instruction": "1. Identify the first row of the grid. This row contains a sequence of colored (non-7) cells forming a pattern. All other rows initially contain only the background color (7).\n2. For each cell in the first row that is not 7, use the pattern, spacing, and color of foreground (non-7) cells as a template.\n3. Construct a triangle with its base as the first row, and each subsequent row below containing one fewer foreground (non-7) cell on each side (left and right) and the central segment shifted inward, using the colors and relative order from the above row.\n   a. For each next row beneath the first, start by trimming away one element from the leftmost and rightmost foreground blocks (if present) that remain in the pattern above.\n   b. Apply the same internal sequencing as in the row above, but only within the new shortened range.\n   c. If a group splits (i.e., if there are two distant colored blocks, and trimming would separate them further), treat them separately and process each block accordingly.\n   d. Any positions outside the new range or within removed blocks remain background (7).\n4. Repeat step 3 for each subsequent row until no foreground (non-7) cells remain or until all rows have been filled.\n5. All cells outside the triangular \"tapered\" pattern remain 7.", "test_input": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7],\n [7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7],\n [7, 7, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7],\n [7, 7, 7, 5, 5, 5, 5, 5, 7, 7, 7, 7],\n [7, 7, 7, 7, 5, 5, 5, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7]]", "expected_output": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7], [7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7], [7, 7, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7], [7, 7, 7, 2, 2, 2, 2, 2, 7, 7, 7, 7], [7, 7, 7, 7, 5, 5, 5, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 2, 7, 7, 7, 7, 7, 7]]}, "b60334d2": {"instruction": "1. For each nonzero cell containing a 5 in the input grid, replace that cell with a 5 in the output grid.\n2. For every 5 in the output grid, form a horizontal three-cell pattern centered at that 5: assign 5 to the center, 1 to both immediate neighbors (left and right), and 5 to the two cells adjacent to each 1 (left of the left 1 and right of the right 1), unless these cells are outside the grid boundaries.\n3. Keep the values of all other cells as 0.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 5, 1, 5, 0, 0, 0, 0, 0],\n [5, 1, 5, 1, 5, 0, 0, 5, 1],\n [0, 5, 1, 5, 0, 0, 5, 1, 5],\n [0, 0, 5, 1, 5, 1, 5, 0, 0],\n [0, 0, 0, 5, 1, 5, 0, 0, 0],\n [0, 0, 0, 0, 5, 1, 5, 1, 5],\n [0, 0, 0, 0, 0, 5, 1, 5, 0],\n [0, 0, 5, 1, 5, 0, 0, 0, 0],\n [0, 5, 1, 5, 0, 0, 0, 0, 0]]", "expected_output": [[5, 1, 5, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0], [5, 1, 5, 5, 1, 5, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 5, 1, 5, 5, 1, 5], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 5, 1, 5, 0, 0, 5, 1, 5], [0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 1, 5, 0, 0, 0, 0, 0]]}, "b6afb2da": {"instruction": "1. Identify all rectangular regions in the input grid where the cells have the value 5. Each such rectangle will be replaced by a stylized border-plus-fill pattern in the output grid.\n2. For each 5-filled rectangle, determine its boundary coordinates (top, bottom, left, right).\n3. In the output grid, replace the 5-filled rectangle as follows:\n   a. Set the four corners of the rectangle to 1.\n   b. Set the cells on the border of the rectangle (excluding corners) to 4.\n   c. Set all inner (non-border) cells of the rectangle to 2.\n4. Keep all zero-valued cells outside the rectangles unchanged in the output grid.", "test_input": [[0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5]], "predicted_output": "[[0, 1, 4, 4, 1, 0, 0, 0, 0, 0],\n [0, 4, 2, 2, 4, 0, 0, 0, 0, 0],\n [0, 4, 2, 2, 4, 0, 0, 0, 0, 0],\n [0, 4, 2, 2, 4, 0, 0, 0, 0, 0],\n [0, 4, 2, 2, 4, 0, 0, 0, 0, 0],\n [0, 1, 4, 4, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 1, 4, 4, 4, 4, 1],\n [0, 0, 0, 0, 4, 2, 2, 2, 2, 4],\n [0, 0, 0, 0, 1, 4, 4, 4, 4, 1]]", "expected_output": [[0, 1, 4, 4, 1, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 1, 4, 4, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1], [0, 0, 0, 0, 4, 2, 2, 2, 2, 4], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1]]}, "b71a7747": {"instruction": "1. Identify the innermost subgrid that is bordered by a different color and contains the distinctive non-background content (in this case, the region bordered by contiguous '3's and containing '1's and '2's).\n2. Extract this subgrid, cropping out all the surrounding padding, borders, and repeated regions.\n3. For all values in the extracted subgrid, replace every number with '3' except for the cells that originally had value '1'. For those, replace with '2'.\n4. Now, identify the zones inside this '3'-filled region where there had been vertical or horizontal lines of '2's inside the border (i.e., vertical or horizontal regions of original '2's adjacent to the main vertical of '1's). For each such cell, set it to '2'.\n5. The central vertical line (the original path of '1's, possibly slightly jagged, but single path) should all be set to '2'.\n6. The final output grid should be a single compact (cropped) block representing the inner shape, using only the numbers '3' for the background, and '2' for the inner path, matching the appearance of the extracted form, with no outer border.", "test_input": [[5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 5], [3, 3, 3, 2, 2, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 1, 1, 1, 2, 2, 3, 3], [5, 5, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 1, 2, 2, 5, 5], [5, 5, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 1, 2, 2, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 1, 2, 2, 5, 5], [5, 5, 5, 2, 2, 1, 1, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 1, 2, 2, 5, 5], [3, 3, 3, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 2, 3, 2, 2, 1, 1, 1, 3, 1, 1, 1, 2, 2, 3, 3], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 5, 5], [3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 2, 2, 3, 2, 2, 2, 1, 2, 3, 2, 2, 2, 2, 2, 3, 3], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 1, 5, 1, 1, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 1, 2, 2, 2, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 1, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 1, 2, 2, 5, 2, 2, 2, 1, 1, 5, 1, 1, 2, 2, 2, 5, 5], [3, 3, 3, 2, 2, 2, 2, 2, 3, 2, 2, 1, 1, 1, 3, 1, 1, 1, 1, 2, 3, 2, 2, 2, 2, 2, 3, 3], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 2, 2, 2, 2, 2, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5, 5, 3, 5, 5, 5, 5]], "predicted_output": "[[3, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3],\n [3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3],\n [3, 2, 2, 2, 3, 3, 2, 2, 2, 2, 3],\n [2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2],\n [2, 2, 3, 2, 2, 2, 2, 3, 2, 2, 2],\n [3, 2, 2, 3, 3, 3, 3, 3, 2, 2, 3],\n [3, 3, 3, 2, 2, 2, 2, 2, 3, 3, 3]]", "expected_output": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2], [2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2], [2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2], [2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2], [2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}, "b7249182": {"instruction": "1. Identify all unique nonzero colors in the input grid. These correspond to central \"seed\" points of each colored pattern.\n2. For each color, locate all its positions in the grid. Let\u2019s call these the seed coordinates for that color.\n3. For each seed coordinate, create a cross-shaped pattern centered at the seed's position according to the following rules:\n    a. From the seed, fill cells along the vertical line (column) for a fixed number of cells above and below the seed, using the seed\u2019s color. The length of this segment matches the vertical distance from the topmost to bottommost seeds of this color in the grid.\n    b. From the seed, fill cells along the horizontal line (row) for a fixed number of cells to the left and right of the seed, using the seed\u2019s color. The length of this segment matches the horizontal distance from the leftmost to rightmost seeds of this color in the grid.\n    c. The overall cross width and height is determined by the distribution of that color's seed positions in the input grid (if there is only one seed, the cross still forms a symmetric pattern as seen in the examples).\n4. Next, for each seed, draw a border region around the cross by filling the immediate outer cells (not part of the cross itself) with the same color. For example, form a square around the cross arms, except for corners if required. (In the examples, this creates a \"box\" around the cross's center, or equivalent ring.)\n5. For each colored pattern generated, ensure no conflicts or overwrites between different colors \u2013 if their regions would overlap, process colors from top rows to bottom, or in order of appearance.\n6. All other grid cells remain unchanged (keep as zero).", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 7, 7, 7, 7, 7, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 0, 0, 7, 0, 0, 0, 0, 0],\n [0, 7, 7, 7, 7, 7, 0, 0, 0],\n [0, 0, 0, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 0, 0, 0], [0, 7, 0, 0, 0, 7, 0, 0, 0], [0, 6, 0, 0, 0, 6, 0, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "b7256dcd": {"instruction": "1. Identify all non-7 colored regions in the input grid; these regions are at first composed predominantly of 6s, but may also include connected non-7 and non-border values, and are typically surrounded or bordered by 7s.\n2. For each region, find the lowest non-7 value within that region (including any special colors like 3, 4, 1, 5, or 8 that may be 'embedded' at a border or inside\u2014whichever is the minimum according to their numeric value).\n3. Replace all 6s (and any other non-7, non-minimum bordering values within the region) in each region with the region's minimum value found in step 2.\n4. Leave all 7s (the background) unchanged.", "test_input": [[4, 7, 6, 7, 7, 7, 5], [6, 6, 6, 7, 7, 7, 7], [7, 7, 6, 7, 1, 7, 7], [7, 7, 7, 7, 6, 6, 7], [7, 7, 7, 7, 6, 6, 7], [6, 6, 8, 7, 7, 7, 7], [7, 6, 7, 7, 7, 7, 7]], "predicted_output": "[[4, 7, 4, 7, 7, 7, 5],\n [4, 4, 4, 7, 7, 7, 7],\n [7, 7, 4, 7, 1, 7, 7],\n [7, 7, 7, 7, 4, 4, 7],\n [7, 7, 7, 7, 4, 4, 7],\n [4, 4, 8, 7, 7, 7, 7],\n [7, 4, 7, 7, 7, 7, 7]]", "expected_output": [[7, 7, 4, 7, 7, 7, 7], [4, 4, 4, 7, 7, 7, 7], [7, 7, 4, 7, 7, 7, 7], [7, 7, 7, 7, 1, 1, 7], [7, 7, 7, 7, 1, 1, 7], [8, 8, 7, 7, 7, 7, 7], [7, 8, 7, 7, 7, 7, 7]]}, "b745798f": {"instruction": "1. Identify all non-background (non-8) color regions in the grid. Each region will be relocated in a new position in the output grid.\n2. For **each identified color region**:\n    a. Determine its minimum bounding rectangle (top, left, bottom, right).\n    b. Extract the region as a subgrid, preserving shape and color.\n3. Place the **first region found (from bottom up, left to right)** in the **top-left corner** of the output grid, preserving its internal arrangement:\n    a. The region should be positioned so its top-left cell starts at (0, 0).\n4. Place the **second region found** directly to the right of the first region, maintaining at least one background cell (8) of horizontal spacing, and preserving its shape.\n5. Place additional regions as follows:\n    a. If all regions cannot fit in the first row (due to grid width constraints), continue in the next row, aligning regions top-aligned in each row, separated by at least one background cell.\n6. Fill all other grid positions with the background color (8).\n7. The **order of region placement** is:\n    a. From bottommost region up,\n    b. Within each row, from leftmost region to right.", "test_input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 3, 3, 8, 9, 9, 8], [8, 8, 8, 8, 8, 6, 6, 8, 8, 8, 3, 8, 9, 8, 8]], "predicted_output": "[[2, 8, 2, 8, 3, 3, 8, 3, 8, 9, 9],\n [2, 2, 8, 8, 8, 8, 8, 8, 8, 9, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [6, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8],\n [6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[9, 9, 9, 9, 9, 9, 9, 8, 3, 3, 3, 3, 3, 3, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [6, 6, 6, 6, 6, 6, 6, 8, 2, 2, 2, 2, 2, 2, 2]]}, "b74ca5d1": {"instruction": "1. For each non-background region in the input grid, identify all the distinct non-background values (i.e., any value not equal to the background value of 0).\n2. For each contiguous region of a non-background value (e.g., regions of 7, 2, 5, 3, 4, 6, 8), replace all cells in that region with the output color corresponding to that region's color mapping, as observed in the sample mappings:\n   - 7 \u2192 7\n   - 2 \u2192 2 (but note the outer frame pattern will be changed\u2014see step 3)\n   - 5 \u2192 5\n   - 8 \u2192 8\n   - 3 \u2192 3\n   - 4 \u2192 4\n   - 6 \u2192 6\n3. For the entire grid, process as follows:\n   - For every row, scan left-to-right for 'frames' or 'lines' of the main structure (e.g., the row(s) that form the biggest non-background horizontal structure), and replace them using the corresponding output colors, following the output style of the examples. Typically, the long horizontal regions in row 0, row 1, and row 2 (and symmetric locations at the bottom) are reframed (e.g., 0 \u2192 7, and then fill in 0 \u2192 0 for inner fill, but keep border frame as 7).\n   - For symmetric or repeated block structures within the grid, preserve their shape but map the internal and border elements per the mappings observed in the examples.\n4. For each block of five consecutive values (vertically or horizontally) forming a \"line\" of the same color (such as a line of five 6s or five 0s), ensure that block's cells are set to the mapped output color as observed in the output samples.\n5. Where an \"edge\" or \"corner\" region in the input is colored (e.g., a 7 in the corner surrounded by 0s), ensure the analogous location in the output retains this color (e.g., keep 7 at the corner).\n6. For every vertical or horizontal region surrounded by background (0s), maintain or convert it to the matching output color and placement found in the output examples, aligning with the output's styling for those regions and their symmetry and spacing.\n7. For every cell that is background (0) in the input and not part of a pattern or border to be transformed (per above), keep as 0 in the output.\n\nNote: The output grid should show a reframing of regions and blocks as in the examples, with the main colored regions mapped to their appropriate values and output style.", "test_input": [[7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 7, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 2, 2, 2, 2, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 8, 8],\n [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0],\n [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n [7, 2, 2, 2, 2, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 4, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 4, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0, 7, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 4, 0, 4, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 4, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0], [7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 3, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "b775ac94": {"instruction": "1. For each nonzero connected component (by color) in the input grid, locate its bounding box (the smallest rectangle containing all its nonzero cells).\n2. For every connected component consisting of the color 8, find all complete 2x2 solid blocks of color 8 within its bounding box. At every location where a 2x2 solid block exists, create a 2x2 solid block of color 4 immediately to the right of that block, provided that space is empty (only zeros).\n3. For every connected component consisting of the color 1, find all complete 2x2 solid blocks of color 1 within its bounding box. At every location where a 2x2 solid block exists, create a 2x2 solid block of color 2 immediately to the right of that block, provided that space is empty.\n4. For every connected component consisting of the color 2, find all horizontal lines of 2 or more contiguous cells of color 2. To the right of any such line (if the next cell(s) are zero), place a horizontal line of color 4 of the same length.\n5. For every component consisting of the color 3, find all vertical lines of 2 or more contiguous cells of color 3. Directly beneath any such line (if the next cell(s) are zero), place a vertical line of color 4 of the same length.\n6. Retain all other nonzero colored cells and positions unchanged from the input.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 4, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 4, 3, 0, 0, 0, 0, 0, 0, 1, 1, 1, 8, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 2, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 2, 2, 0, 0, 0, 0, 0, 3, 3, 3, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 3, 3, 0, 0, 0, 0, 0, 1, 1, 1, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 4, 3, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "b782dc8a": {"instruction": "1. Identify any contiguous horizontal or vertical segments of non-background (non-zero) cells that form rows or columns containing a sequence of \"central\" colors among the background and wall color 8 (the accent color sequence from the corresponding examples). For this grid, the \u201ccentral\u201d color sequence is [4, 3], as seen at row 2, columns 6 and 7.\n\n2. For each row that contains a nonzero, non-wall (non-8) color, read the sequence of nonzero, non-wall color(s) as the sequence to \"propagate\" into the empty (background, 0) cells in all other rows in the \"active\" area to the left and right of the containing wall (8) columns.\n\n3. For rows without explicit central color(s) in the sequence but that are located between such rows (vertically)\u2014i.e. those that have zeros (background) between the wall columns (8s) in the middle\u2014fill the space between the same wall columns in these rows by repeating (cycling) the accent color pattern [4, 3], starting at the column where it appeared in the reference row.\n\n4. If the cycling sequence continues beyond the last central color, wrap around to the beginning of the sequence and continue filling, until the space between the two wall columns is filled.\n\n5. Retain all existing wall (8) and background (0) positions outside these accent fill zones. Do not alter any other part of the grid.", "test_input": [[8, 8, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8, 8], [0, 8, 0, 0, 0, 0, 4, 3, 8, 0, 0, 0, 0, 0, 8], [0, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0], [8, 8, 8, 8, 8, 0, 8, 8, 8, 0, 8, 0, 8, 0, 8], [0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8], [8, 8, 8, 0, 8, 8, 8, 0, 8, 0, 8, 0, 8, 8, 8], [0, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8], [8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8], [8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 0, 8], [0, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8], [8, 0, 8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8], [8, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[8, 8, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 0, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 0, 0, 0, 0, 4, 3, 8, 0, 0, 0, 0, 0, 8],\n [0, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 0, 4, 3, 8, 0, 8, 0, 8, 0, 0],\n [8, 8, 8, 8, 8, 0, 8, 8, 8, 0, 8, 0, 8, 0, 8],\n [0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8],\n [8, 8, 8, 0, 8, 8, 8, 0, 8, 0, 8, 0, 8, 8, 8],\n [0, 0, 4, 3, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0],\n [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8],\n [8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8],\n [8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 0, 8],\n [0, 0, 0, 0, 0, 0, 4, 3, 8, 0, 0, 0, 0, 0, 8],\n [8, 0, 8, 8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8],\n [8, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0]]", "expected_output": [[8, 8, 4, 8, 0, 0, 8, 3, 4, 3, 4, 3, 4, 3, 4], [0, 8, 3, 8, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8, 8], [0, 8, 4, 3, 4, 3, 4, 3, 8, 0, 0, 0, 0, 0, 8], [0, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 3, 4, 3, 8, 0, 8, 0, 0], [8, 8, 8, 8, 8, 0, 8, 8, 8, 4, 8, 0, 8, 0, 8], [4, 3, 4, 3, 8, 0, 0, 0, 8, 3, 8, 0, 8, 0, 8], [8, 8, 8, 4, 8, 8, 8, 0, 8, 4, 8, 0, 8, 8, 8], [0, 0, 8, 3, 4, 3, 8, 0, 8, 3, 8, 0, 0, 0, 0], [8, 0, 8, 8, 8, 4, 8, 8, 8, 4, 8, 8, 8, 0, 8], [8, 0, 0, 0, 8, 3, 4, 3, 4, 3, 4, 3, 8, 0, 8], [8, 8, 8, 0, 8, 4, 8, 8, 8, 8, 8, 8, 8, 0, 8], [4, 3, 8, 0, 8, 3, 8, 0, 0, 0, 0, 0, 0, 0, 8], [8, 4, 8, 8, 8, 4, 8, 0, 8, 8, 8, 8, 8, 8, 8], [8, 3, 4, 3, 4, 3, 8, 0, 8, 0, 0, 0, 0, 0, 0]]}, "b7955b3c": {"instruction": "1. Identify all contiguous regions in the input grid that contain the value 8.\n2. For each detected region of 8s, replace all 8s in that region with the majority color of the \"container\" region they interrupt (the area in which the 8s are encased). If there are ties, select the surrounding color that is most prevalent or immediately adjacent in the same row/column.\n3. For regions where 8s border a different region (such as between two distinct colored blocks), replace 8 with the color present in the same row or column that would assure the interior region becomes filled and regular (matching examples).\n4. In all locations where a 9 borders or fills an interior region, fill those cells with the color of the region's boundary to make all regions consistent and without 9s interrupting colored regions.\n5. Ensure that each contiguous region (group of equal numbers) is now solidly filled, without any patches of 8 or 9 (or other interruptions), matching the pattern in the surrounding colors; keep outer boundaries intact.\n6. Do not alter the grid areas that are already uniform and not impacted by internal 8s or 9s.", "test_input": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 2, 2, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 8, 3, 3, 3, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1], [1, 1, 1, 1, 6, 6, 8, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 8, 8, 8, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 8, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 8, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 8, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 8, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 8, 8, 8, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 8, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 8, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 8, 8, 8, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 9, 9, 9, 8, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 8, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 6, 8, 8, 8, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 1, 1, 8, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "predicted_output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1],\n [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1],\n [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1],\n [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1],\n [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1],\n [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1],\n [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1],\n [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 3, 3, 3, 1, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 1, 1],\n [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 3, 1, 1],\n [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]", "expected_output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1], [1, 1, 2, 2, 6, 6, 6, 6, 6, 6, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 2, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 4, 4, 6, 6, 6, 6, 6, 6, 4, 9, 9, 9, 4, 4, 4, 4, 4, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 1, 9, 9, 9, 1, 3, 3, 3, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 3, 3, 1, 1], [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 9, 9, 9, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "b7999b51": {"instruction": "1. Identify all contiguous nonzero color-block regions in the grid (ignoring the background zeros). These regions are typically rectangular blocks of the same color (sometimes adjacent blocks of different colors).\n2. Find the set of non-background blocks in the upper part of the grid (the first group of contiguous nonzero blocks as you scan rows from top). These usually appear as a band or cluster near the top of the grid.\n3. Find the set of non-background blocks in the lower part of the grid (the next group of contiguous nonzero blocks as you scan rows from top, after a row or several rows of zeros separate these regions).\n4. For both the upper and lower regions, identify the distinct nonzero colors present in each.\n5. For the output grid:\n    a. Create a new grid where the number of rows equals the number of contiguous colored rows in the lower region plus one, and the number of columns equals the sum of the number of color blocks present in the leftmost columns of each upper/lower region.\n    b. For each row, assign the first column to the leftmost color present in the bottom region for that row index\u2014if no color exists for that row index (due to fewer rows than the maximum block height), use 0.\n    c. For the next columns, fill from left to right with colors:\n        - The second column is filled with the leftmost color present in the top region for that row index (or 0 if not present).\n        - The third and subsequent columns are filled using the next distinct color blocks found in the upper regions and any other distinct blocks from bottom regions, row-wise, filling with 0 as appropriate if there is no block at that position for that row index.\n6. Place the colors row by row in the output grid as per above. Any positions where there is no corresponding color block from the input regions, fill with 0.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 2, 2, 2, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[6, 2, 3, 1, 8],\n [6, 2, 3, 1, 8],\n [6, 2, 3, 1, 8],\n [6, 2, 3, 1, 8],\n [6, 2, 3, 1, 8],\n [6, 0, 3, 0, 0]]", "expected_output": [[6, 3, 2, 1, 8], [6, 3, 2, 1, 0], [6, 3, 2, 0, 0], [6, 3, 0, 0, 0], [6, 3, 0, 0, 0], [6, 0, 0, 0, 0]]}, "b7cb93ac": {"instruction": "1. Identify all nonzero cells in the input grid. Find the topmost, bottommost, leftmost, and rightmost coordinates among all nonzero cells. This defines the bounding rectangle containing all colored regions.\n2. Extract the minimal bounding rectangle that contains all nonzero elements from the input grid, preserving their original colors and relative positions.\n3. Rotate this extracted rectangle 90 degrees clockwise.\n4. Output the rotated rectangle as the new grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 3],\n [0, 6, 0, 0, 0, 3, 3],\n [8, 8, 8, 0, 0, 0, 0],\n [8, 0, 0, 0, 0, 0, 0],\n [8, 0, 0, 0, 0, 0, 0],\n [8, 0, 6, 6, 0, 0, 0]]", "expected_output": [[8, 8, 8, 8], [8, 3, 6, 8], [3, 3, 6, 6]]}, "b7f8a4d8": {"instruction": "1. Divide the grid into blocks/regions according to repeating patterns. In this grid, each nonzero region is a 5x5 square, arranged in a grid with blocks separated by rows or columns of zeros.\n2. For each 5x5 nonzero block, identify its type from the repeating block patterns. There are two main types in the examples:\n   - \"Solid\" block: Surrounded by 4's, with a center of 3's or 2's.\n   - \"Hollow\" block: Surrounded by 4's, with a center of 8's or 2's.\n3. For every group of four horizontally or vertically adjacent 5x5 blocks forming a 2x2 arrangement, insert a \"central\" feature at the point where the four blocks meet:\n   a. If the four blocks are all \"solid\" type (with a 3 or 2 center), insert a 3 at the point of intersection (center of the 2x2 of blocks).\n   b. If the four blocks are all \"hollow\" type (with an 8 or 2 center), insert an 8 at the intersection.\n   c. If the four blocks are a mix of types, assign the intersection by block-majority rule (use the center pixel value common for most surrounding blocks).\n4. In places where two blocks meet only along an edge (horizontally and vertically), insert a 3 or 8 respectively as in step 3, in the zero (background) region at the center of the separating edge. Use the color of the two adjacent block centers.\n5. Leave the remaining zeros at the background unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 3, 3, 3, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4, 3, 3, 3, 4, 0, 0, 4],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4],\n [0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 3, 3, 3, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 3, 3, 3, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 2, 2, 2, 4, 3, 3, 4, 3, 3, 3, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 2, 2, 2, 4, 0, 0, 4, 8, 8, 8, 4, 8, 8, 4, 8, 8, 8, 4, 0, 0, 4, 2, 2, 2, 4, 0, 0, 4], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4]]}, "b7fb29bc": {"instruction": "1. Identify the rectangular frame formed by the outermost '3's in the grid. This forms the boundary of the non-zero pattern. The frame is one cell thick and encloses an interior region.\n2. For all cells inside this rectangular frame (but not on the frame itself), assign values as follows:\n    a. Start at the first layer inside the frame:\n        - Fill the entire layer (all cells at a distance of 1 from the frame) with '4's, except as specified below.\n    b. For each subsequent inner layer (alternating as needed based on the pattern\u2019s complexity), assign '2's and '4's according to the following rules based on the examples:\n        - Fill any region that was '0' and is not already assigned '4' (from the step above) with '2' if:\n            * The cell is surrounded on left and right (or above and below) by zeros in the input, following the snake-like or ladder structure seen in the samples. \n    c. If there are any '3's in the interior that were present in the input (such as in the \"ladder\" steps or diagonal structures), copy them as '3' in the output in the same location.\n    d. In all other interior places that were '0' in the input and do not match the above cases, fill with '4'.\n3. Leave all cells outside the outer frame unchanged (typically zeros).\n4. The outer frame of '3's remains intact and unmodified in all output grids.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 2, 2, 2, 2, 2, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 2, 4, 4, 4, 2, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 2, 4, 3, 4, 2, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 2, 4, 4, 4, 2, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 2, 2, 2, 2, 2, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0],\n [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 2, 2, 2, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 4, 4, 2, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 3, 4, 2, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 4, 4, 2, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 2, 2, 2, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 4, 4, 4, 4, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 2, 2, 2, 2, 2, 4, 2, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "b8825c91": {"instruction": "1. Identify all regions in the grid where a contiguous vertical or horizontal sequence of the same value occupies four adjacent columns or rows (for example, a 4x1 or 1x4 block), especially those composed of the same digit (such as blocks of 4s).\n2. For all such found blocks that align with the center area of the grid (not on the outermost border), check the corresponding location in the lower right (diagonal) quadrant: if a 4x1 or 1x4 block of 4s in the input grid coincides with a similar block of 1s in the lower right quadrant, replace that block of 4s with 1s in the lower right quadrant.\n3. For horizontal lines immediately above or below a central block of 4s, if the lines to the left and right of the 4-block change to another value in the output, for each, update the rightmost and leftmost element of that segment to 6 (matching surrounding context).\n4. For any vertical lines immediately to the left or right of a central block of 4s, if the top or bottom of the 4-block changes to another value in the output, update accordingly (typically from a 4 to a 6 if that's what the local context suggests).\n5. In the top and bottom halves of the grid, look for 5s in the blocks where the output removes or transforms a corresponding 4. Replace those 5s with the value found in the output (usually 6 or 1, depending on the vertical position and context).\n6. For the leftmost and rightmost columns, as well as the top and bottom rows (i.e., the grid's border), ensure that no changes are made except when adjacent to one of the central \"block\" pattern changes previously identified.\n7. After performing these replacements, the blocks of 4s in the center will have been mostly replaced by 1s or 6s, and the single-row or single-column lines above and below updated to match the pattern seen in the output.", "test_input": [[7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7], [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7], [8, 1, 6, 9, 2, 6, 4, 4, 4, 6, 6, 2, 9, 6, 1, 8], [1, 8, 9, 1, 6, 6, 4, 4, 4, 1, 6, 6, 1, 9, 8, 1], [9, 8, 2, 6, 8, 7, 4, 4, 4, 6, 4, 4, 4, 4, 8, 9], [8, 8, 6, 6, 7, 7, 6, 5, 5, 6, 4, 4, 4, 4, 8, 8], [2, 6, 6, 1, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 6, 2], [6, 6, 1, 1, 6, 5, 5, 7, 7, 5, 4, 4, 4, 4, 6, 6], [6, 6, 1, 1, 6, 5, 5, 7, 7, 5, 5, 6, 1, 1, 6, 6], [2, 6, 6, 1, 6, 6, 5, 5, 5, 5, 6, 6, 1, 6, 6, 2], [8, 8, 6, 6, 7, 7, 6, 5, 5, 6, 7, 7, 6, 6, 8, 8], [9, 8, 2, 6, 8, 7, 6, 6, 6, 6, 7, 8, 6, 2, 8, 9], [1, 8, 9, 1, 6, 6, 1, 1, 1, 1, 6, 6, 1, 9, 8, 1], [8, 1, 6, 9, 2, 6, 6, 1, 1, 6, 6, 2, 9, 6, 1, 8], [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7], [7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7]], "predicted_output": "[[7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7],\n [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7],\n [8, 1, 6, 9, 2, 6, 4, 4, 4, 6, 6, 2, 9, 6, 1, 8],\n [1, 8, 9, 1, 6, 6, 4, 4, 4, 1, 6, 6, 1, 9, 8, 1],\n [9, 8, 2, 6, 8, 7, 4, 4, 4, 6, 1, 1, 1, 1, 8, 9],\n [8, 8, 6, 6, 7, 7, 6, 1, 1, 6, 6, 6, 6, 6, 8, 8],\n [2, 6, 6, 1, 6, 6, 1, 1, 1, 1, 6, 6, 6, 6, 6, 2],\n [6, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 6],\n [6, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 6],\n [2, 6, 6, 1, 6, 6, 1, 1, 1, 1, 6, 6, 1, 6, 6, 2],\n [8, 8, 6, 6, 7, 7, 6, 1, 1, 6, 6, 6, 6, 6, 8, 8],\n [9, 8, 2, 6, 8, 7, 6, 6, 6, 6, 1, 1, 1, 1, 8, 9],\n [1, 8, 9, 1, 6, 6, 1, 1, 1, 1, 6, 6, 1, 9, 8, 1],\n [8, 1, 6, 9, 2, 6, 6, 1, 1, 6, 6, 2, 9, 6, 1, 8],\n [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7],\n [7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7]]", "expected_output": [[7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7], [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7], [8, 1, 6, 9, 2, 6, 6, 1, 1, 6, 6, 2, 9, 6, 1, 8], [1, 8, 9, 1, 6, 6, 1, 1, 1, 1, 6, 6, 1, 9, 8, 1], [9, 8, 2, 6, 8, 7, 6, 6, 6, 6, 7, 8, 6, 2, 8, 9], [8, 8, 6, 6, 7, 7, 6, 5, 5, 6, 7, 7, 6, 6, 8, 8], [2, 6, 6, 1, 6, 6, 5, 5, 5, 5, 6, 6, 1, 6, 6, 2], [6, 6, 1, 1, 6, 5, 5, 7, 7, 5, 5, 6, 1, 1, 6, 6], [6, 6, 1, 1, 6, 5, 5, 7, 7, 5, 5, 6, 1, 1, 6, 6], [2, 6, 6, 1, 6, 6, 5, 5, 5, 5, 6, 6, 1, 6, 6, 2], [8, 8, 6, 6, 7, 7, 6, 5, 5, 6, 7, 7, 6, 6, 8, 8], [9, 8, 2, 6, 8, 7, 6, 6, 6, 6, 7, 8, 6, 2, 8, 9], [1, 8, 9, 1, 6, 6, 1, 1, 1, 1, 6, 6, 1, 9, 8, 1], [8, 1, 6, 9, 2, 6, 6, 1, 1, 6, 6, 2, 9, 6, 1, 8], [7, 1, 1, 8, 8, 8, 6, 6, 6, 6, 8, 8, 8, 1, 1, 7], [7, 7, 8, 1, 9, 8, 2, 6, 6, 2, 8, 9, 1, 8, 7, 7]]}, "b8cdaf2b": {"instruction": "1. Identify the bottom two non-empty rows. Let the bottommost filled row (row N) be the \"base row,\" and the row directly above it (row N-1) be the \"mid row.\" In these two rows, there is a horizontal bar of three or more identical nonzero values at the center. The cells directly above this horizontal bar (in row N-2 and above) are empty.\n2. In the base row (row N), note the position and value of the different colored tiles. These base tiles will also be used to define new tiles to be placed in the upper rows.\n3. For the mid row (row N-1), identify the value of the center horizontal bar (length 3 or more). This becomes the \"copy value\" for the pattern to be placed above.\n4. Fill row N-2 in the following way: \n    - For every nonzero cell in row N-1 (the mid row), copy its value into row N-2, but only at the same columns as the nonzero cells in mid row.\n5. Fill row N-3 with the \"copy value\" from step 3 at columns that match the edges of the mid row bar (i.e., the first and last nonzero cells of the mid row), leaving other cells as 0.\n6. If the horizontal bar in mid row has length greater than 3, continue the diagonal bars for each extra offset: For each step higher (row N-4, etc.), place the \"copy value\" at positions diagonally outward from the edges of the previous bar, stopping if you go outside the grid.\n7. All other cells are left unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 8, 8, 2, 2, 2, 8, 8, 8]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 0, 2, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 2, 0, 0],\n [0, 2, 0, 0, 0, 0, 0, 2, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 0, 0, 0],\n [0, 0, 0, 8, 8, 8, 0, 0, 0],\n [8, 8, 8, 2, 2, 2, 8, 8, 8]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 2], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 8, 8, 2, 2, 2, 8, 8, 8]]}, "b91ae062": {"instruction": "1. For each cell in the input grid of size N x N, replace it with an N x N block in the output grid, where N is the side length of the input grid.\n2. For each cell (i, j) in the input grid, fill the corresponding block in the output grid with the value of the cell (i, j). Specifically, if the value in cell (i, j) is V, then the block of rows from i*N to (i+1)*N-1 and columns from j*N to (j+1)*N-1 in the output grid is filled with V.\n3. Repeat this for each cell, so that the output grid is formed by each input cell's value expanded into an N x N block in the correct relative position.", "test_input": [[0, 1, 0], [0, 8, 7], [9, 9, 0]], "predicted_output": "[[0, 0, 0, 1, 1, 1, 0, 0, 0],\n [0, 0, 0, 1, 1, 1, 0, 0, 0],\n [0, 0, 0, 1, 1, 1, 0, 0, 0],\n [0, 0, 0, 8, 8, 8, 7, 7, 7],\n [0, 0, 0, 8, 8, 8, 7, 7, 7],\n [0, 0, 0, 8, 8, 8, 7, 7, 7],\n [9, 9, 9, 9, 9, 9, 0, 0, 0],\n [9, 9, 9, 9, 9, 9, 0, 0, 0],\n [9, 9, 9, 9, 9, 9, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0]]}, "b942fd60": {"instruction": "1. For each row in the input grid, identify the leftmost (minimum column index) cell containing the value 2. If multiple such cells exist in a row, process only the leftmost one.\n2. For each row, if a cell with value 2 exists, draw a vertical line (downwards and upwards from that cell) by filling all empty cells (value 0) in that column with the value 2, except for cells containing nonzero values other than 2 (i.e., stop at obstacles).\n3. For the row containing the leftmost 2, starting from the leftmost 2, fill all empty cells (value 0) to the right of it in that row with 2, stopping when a nonzero (non-2) cell is encountered.\n4. For each row, starting from the leftmost 2 (if it exists), fill all empty cells (value 0) to the right of it in that row with 2, stopping at nonzero cells.\n5. For each cell in the same column as the leftmost 2, fill all empty (zero-valued) cells above and below with value 2, stopping at nonzero cells.\n6. All other cells retain their original values.", "test_input": [[0, 0, 0, 8, 0, 0, 0, 0, 7, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 6, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 3, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 8, 0, 0, 0, 7, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[2, 0, 0, 8, 0, 0, 0, 0, 7, 0, 0, 3],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n [2, 2, 2, 2, 2, 2, 6, 0, 0, 0, 7, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6],\n [2, 0, 0, 3, 0, 0, 0, 8, 0, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0],\n [2, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n [2, 0, 8, 0, 0, 0, 7, 0, 0, 6, 0, 0],\n [2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 8, 0, 2, 0, 0, 7, 0, 0, 3], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 6, 0, 0, 2, 0, 6, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 6, 0, 2, 0, 7, 0], [0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 6], [0, 0, 0, 3, 0, 2, 0, 8, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 0, 0], [0, 0, 7, 2, 0, 2, 0, 0, 2, 0, 0, 3], [0, 0, 8, 2, 2, 2, 7, 0, 2, 6, 0, 0], [0, 0, 0, 2, 0, 3, 0, 0, 2, 0, 0, 0]]}, "b94a9452": {"instruction": "1. Identify the smallest non-background (non-zero) rectangle in the input grid that contains all nonzero elements. This is the \"active\" subgrid.\n2. Copy this active subgrid to a new grid, preserving relative color arrangement.\n3. Replace the outermost layer (border) of the copied subgrid with the color found immediately inside the original border in the input (i.e., the color that forms the \"frame\" inside the border, typically the color surrounding the innermost region).\n4. Leave all inner elements unchanged except those replaced at the border in step 3.\n5. Return the new, tightly-cropped grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 3, 3, 8, 8, 3, 3, 0, 0, 0, 0, 0], [0, 0, 3, 3, 8, 8, 3, 3, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3],\n [3, 3, 8, 8, 3, 3],\n [3, 3, 8, 8, 3, 3],\n [3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3]]", "expected_output": [[8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8], [8, 8, 3, 3, 8, 8], [8, 8, 3, 3, 8, 8], [8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8]]}, "b9630600": {"instruction": "1. Identify all connected regions (blocks) of nonzero (3) cells within the input grid.\n2. For each block, merge any blocks in the same row or column that are connected by a direct line of adjacent (horizontal or vertical, not diagonal) \"3\"s with no gap.\n3. For every resulting connected block:\n    a. If multiple similar shapes or lines of \"3\"s, combine them into a single solid block. Where adjacent rectangular or straight segments of \"3\"s (either in rows or columns) are separated by single-cell-wide gaps, fill those gaps to connect them into one region.\n    b. Remove interior holes in vertical or horizontal lines/rectangles of \"3\"s, so that every rectangular region becomes solid.\n    c. Remove isolated vertical lines of \"3\"s with no horizontal extension unless they directly connect larger horizontal blocks.\n    d. Retain only the merged or filled regions shaped similar to those in the output examples\u2014favoring larger rectangles, L-shapes, or thick connected lines over thinner or gapped structures.\n4. Leave all other cells as zero.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 3, 3, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 3, 3, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "b9b7f026": {"instruction": "1. Examine the input grid and identify all distinct non-zero colors present.\n2. For each non-zero color, count the total number of its occurrences in the grid.\n3. Find the non-zero color that appears the most times (i.e., has the highest frequency count).\n4. Output a single-cell grid ([[X]]) where X is the value of the color with the highest occurrence.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 5, 5, 5, 8, 8, 8, 8, 0, 4, 4, 4, 4, 0, 0], [0, 5, 5, 5, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 7, 7, 7, 7, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 7, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0]], "predicted_output": "[[2]]", "expected_output": [[7]]}, "ba1aa698": {"instruction": "1. Identify the unique rectangular \"region of interest\" in the grid, which consists of a border of a single unique color (the border color) enclosing a field of another color, possibly with features inside. In this case, the outer border is color 4. \n2. Within this region, locate any distinct subrectangles or regions \"framed\" by the border. For these puzzles, focus on one (typically the leftmost and/or lowermost) such subrectangle that is surrounded by the border color on all sides.\n3. Crop the input grid so that only this single main region, including its border, remains. This cropping will yield a smaller rectangular grid centered around the leftmost instance of the repeated pattern.\n   - Specifically, this means discarding continuous banded repetitions (vertical/horizontal tiling) and isolating only one self-contained chunk bordered by color 4 on all sides.\n   - In the provided test case, extract the 16x7 subgrid that starts at the top left corner (row 0, column 0) and ends at the first complete occurrence of the bordered region (row 15, column 6).\n4. The result should be a grid of reduced dimensions (but with the same local internal structure and border), matching the pattern seen in the output examples.", "test_input": [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 8, 8, 8, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 8, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 8, 8, 8, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 8, 8, 8, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 8, 8, 8, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "predicted_output": "[[4, 4, 4, 4, 4, 4, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 8, 8, 8, 3, 4],\n [4, 3, 3, 8, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 3, 3, 3, 3, 3, 4],\n [4, 4, 4, 4, 4, 4, 4]]", "expected_output": [[4, 4, 4, 4, 4, 4, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 8, 8, 8, 3, 4], [4, 3, 3, 8, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 3, 3, 3, 3, 3, 4], [4, 4, 4, 4, 4, 4, 4]]}, "ba26e723": {"instruction": "1. For each row in the grid, perform the following transformations based on the row index (row 0 is top, row 1 is middle, row 2 is bottom):\n\n2. For the middle row (row 1):  \n   a. Starting at column 0, replace every 3rd cell (columns 0, 3, 6, 9, 12, 15, ...) with the value 6.  \n   b. Leave all other cells unchanged.\n\n3. For the top row (row 0):  \n   a. Starting at column 3, and then every 6th cell after that (columns 3, 9, 15, ...), replace the value in that cell with 6.  \n   b. Additionally, replace the cell at column 0 with 0 (keep as is).  \n   c. All other cells remain unchanged.\n\n4. For the bottom row (row 2):  \n   a. Starting at column 0, replace every 6th cell (columns 0, 6, 12, ...) with the value 6.  \n   b. All other cells remain unchanged.", "test_input": [[0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4]], "predicted_output": "[[0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0],\n [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4],\n [6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4]]", "expected_output": [[0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4], [6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4]]}, "ba97ae07": {"instruction": "1. Identify the contiguous rows in the input grid which contain a horizontal band (rows) of a unique color different from the main vertical band\u2014these are \"special\" rows. In all provided examples, these are the horizontal bands with a repeated color that spans the row (e.g., row 3 in the first example, rows 3-5 in the fourth, rows 2-3 in the test case).\n2. For each \"special\" row, identify the columns in which the vertical band of a different unique color appears (e.g., the 3rd column in the first example, columns 2-3 in the fourth, columns 2-3 in the test).\n3. In each special row, replace the segment(s) of the horizontal band's color that coincide(s) with the column(s) of the vertical band with the vertical band's color:  \n\u2003\u2003- That is, wherever the horizontal band overlaps with the vertical band, set that cell to the color of the vertical band, and set the remaining cells in the row to the color of the horizontal band from the original grid.\n4. All other cells in the grid (outside the special row(s)) remain unchanged.", "test_input": [[0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [5, 5, 4, 4, 5, 5], [5, 5, 4, 4, 5, 5], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0]], "predicted_output": "[[0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [5, 5, 4, 4, 5, 5],\n [5, 5, 4, 4, 5, 5],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0],\n [0, 0, 4, 4, 0, 0]]", "expected_output": [[0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0]]}, "ba9d41b8": {"instruction": "1. For each contiguous rectangular block of nonzero cells with a uniform color (i.e., a solid-colored region of the same value, such as all 8s, all 7s, all 6s, all 4s, etc.), apply the following transformation to that region:\n    a. Leave the outermost border of that region (top row, bottom row, leftmost column, rightmost column) unchanged.\n    b. Within the interior (non-border) cells of that region, replace their value as follows: alternate between setting interior cells to the region's original color and to 0, in a checkerboard pattern starting from the top-left interior cell (just inside the border) as the same color, and alternating every cell in both row and column directions.\n2. Repeat this process independently for every solid-colored block in the grid, ensuring that only the interiors are modified and the outer borders are preserved.\n3. All cells outside of these colored regions (value 0) remain unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0],\n [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0],\n [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 7, 0, 7, 0, 7, 7, 7, 0],\n [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0],\n [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 7, 0, 7, 0, 7, 7, 7, 0],\n [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0],\n [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0],\n [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 0, 4, 0, 4, 0],\n [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 0, 4, 0, 4, 0, 4, 0],\n [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 0, 4, 0, 4, 0],\n [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 4, 4, 4, 4, 4, 0],\n [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 0, 4, 0, 4, 0],\n [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0],\n [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0], [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 7, 0, 7, 0, 7, 0, 7, 0], [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0], [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 7, 0, 7, 0, 7, 0, 7, 0], [0, 8, 8, 0, 8, 0, 8, 0, 8, 0, 7, 0, 7, 0, 7, 0, 7, 7, 0], [0, 8, 0, 8, 0, 8, 0, 8, 8, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 0, 4, 0, 4, 0], [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 4, 4, 0, 4, 4, 0], [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 0, 4, 0, 4, 0], [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 4, 4, 0, 4, 4, 0], [0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 6, 0, 4, 4, 4, 4, 4, 0], [0, 6, 6, 0, 6, 0, 6, 0, 6, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0]]}, "bae5c565": {"instruction": "1. Identify the first row in the grid that contains values different from the background value (5). Copy this row.\n2. Remove this identified row from its original position in the grid.\n3. Starting from the bottom of the grid, overwrite as many of the lowest rows as needed with shifted copies of the extracted row, such that each new row is shifted one cell left relative to the row directly below it. Align the last element of the copied row with the bottom row's rightmost cell. Fill any positions that fall outside the grid bounds during shifting with the background value (5).\n4. In every overwritten row, if there is an \"8\" in the column where 8 appears in the original input grid (the vertical sequence of 8s), preserve the \"8\" instead of the copied row's value.\n5. All other cells in the grid not affected by copied rows or the preserved \"8\"s are filled with the background value (5).", "test_input": [[4, 6, 7, 2, 9, 5, 3, 3, 4, 3, 3], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5]], "predicted_output": "[[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [4, 6, 7, 2, 9, 8, 3, 3, 4, 3, 3],\n [5, 4, 6, 7, 2, 8, 9, 3, 3, 4, 3],\n [5, 5, 4, 6, 7, 8, 2, 9, 3, 3, 4],\n [5, 5, 5, 4, 6, 8, 7, 2, 9, 3, 3],\n [5, 5, 5, 5, 4, 8, 6, 7, 2, 9, 3],\n [5, 5, 5, 5, 5, 8, 4, 6, 7, 2, 9]]", "expected_output": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 8, 5, 5, 5, 5, 5], [5, 5, 5, 5, 9, 8, 3, 5, 5, 5, 5], [5, 5, 5, 2, 9, 8, 3, 3, 5, 5, 5], [5, 5, 7, 2, 9, 8, 3, 3, 4, 5, 5], [5, 6, 7, 2, 9, 8, 3, 3, 4, 3, 5], [4, 6, 7, 2, 9, 8, 3, 3, 4, 3, 3]]}, "baf41dbf": {"instruction": "1. Identify all 3x3 block structures composed of cells with the value 3 in the input grid.\n2. For each identified 3x3 block, expand it into a larger square border:\n    a. The new border should be a solid line of 3s that forms a square surrounding the original 3x3 block, with a single-cell gap between the new border and the original 3x3 block.\n    b. Fill all cells in the new border with 3, resulting in a hollow square \u201cframe\u201d (of width 1) encompassing the original block.\n    c. Maintain any existing nonzero values (such as 6) that are not part of the 3x3 block or new frame in their original positions.\n3. Clear (set to 0) all cells inside the new hollow frame that are outside the original block (i.e., between the original block and the new border), except for any retained numbers like 6 as found in the original.\n4. Copy all other nonzero values (like 6) from the input grid into the output grid, retaining their positions.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 3, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 6, 0, 0, 3, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "bb43febb": {"instruction": "1. Identify all contiguous rectangular regions of nonzero (5-colored) cells that are at least 3x3 in size. These represent the main shapes to process.\n2. For each identified region, replace all inner cells (not on the outermost border of the region) with the value 2, while keeping the outermost border cells as 5. For a rectangle from row r1 to r2 and column c1 to c2, the inner area is rows (r1+1) to (r2-1) and columns (c1+1) to (c2-1).\n3. Leave all zero (0) background cells and any smaller (non-rectangular or thin) 5's regions unchanged.", "test_input": [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5]], "predicted_output": "[[5, 5, 5, 5, 5, 5, 0, 0, 0, 0],\n [5, 2, 2, 2, 2, 5, 0, 0, 0, 0],\n [5, 2, 2, 2, 2, 5, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 5, 5, 5, 5, 5, 5, 5],\n [0, 0, 0, 5, 2, 2, 2, 2, 2, 5],\n [0, 0, 0, 5, 2, 2, 2, 2, 2, 5],\n [0, 0, 0, 5, 2, 2, 2, 2, 2, 5],\n [0, 0, 0, 5, 2, 2, 2, 2, 2, 5],\n [0, 0, 0, 5, 5, 5, 5, 5, 5, 5]]", "expected_output": [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 2, 2, 2, 2, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5]]}, "bb52a14b": {"instruction": "1. For each row in the grid, scan for patterns where the sequence `[1, 0, 0, 1]` occurs such that these numbers are contiguous horizontally in row (with or without zeros at the boundaries of the grid).\n2. When such a horizontal sequence `[1, 0, 0, 1]` is found, replace the leftmost `1` with `4`, the two `0`s with `8` and `4` (such that the four cells become `[4, 8, 4, 1]`), with the rightmost `1` remaining unchanged.\n3. Similarly, for any vertical sequence `[1, 0, 0, 1]` in a column, replace top `1` with `4`, the two `0`s with `8` and `4`, and the bottom `1` remains unchanged\u2014thus, that vertical is transformed to `[4, 8, 4, 1]` from top to bottom.\n4. Continue scanning and transforming the grid for all such patterns, both horizontally and vertically, until no more `[1, 0, 0, 1]` sequences are present.\n5. All other cell values and patterns remain unchanged.", "test_input": [[0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 8, 0], [0, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0, 0, 0, 8, 8, 0, 0, 0, 1, 0, 0], [0, 0, 8, 0, 0, 8, 8, 0, 0, 0, 1, 8, 1, 0, 0, 8, 0, 0, 0, 1, 0, 0], [0, 8, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0], [0, 1, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 4, 8, 8, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 8, 1, 0], [0, 0, 0, 0, 4, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 8, 8, 8, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0], [1, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 8, 0], [0, 8, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 8, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 1, 0, 8, 0, 8, 1, 0, 1, 0, 0, 0]], "predicted_output": "[[0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 4, 8, 4, 1, 0, 0, 0, 0, 8, 0],\n [0, 0, 0, 4, 8, 4, 1, 8, 8, 1, 0, 0, 0, 0, 8, 8, 0, 0, 0, 1, 0, 0],\n [0, 0, 8, 0, 0, 8, 8, 0, 0, 0, 4, 8, 4, 0, 0, 8, 0, 0, 0, 1, 0, 0],\n [0, 8, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 4, 8, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 4, 8, 4, 1, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0],\n [0, 1, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8],\n [8, 0, 0, 0, 4, 8, 8, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 8, 1, 0],\n [0, 0, 0, 0, 4, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n [0, 8, 0, 0, 0, 4, 8, 4, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8],\n [0, 0, 0, 0, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n [0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0],\n [0, 0, 8, 8, 8, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0],\n [4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 8, 0],\n [0, 8, 0, 0, 8, 4, 8, 4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 8, 1, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 1, 0, 8, 0, 8, 1, 0, 1, 0, 0, 0]]", "expected_output": [[0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 8, 0], [0, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0, 0, 0, 8, 8, 0, 0, 0, 1, 0, 0], [0, 0, 8, 0, 0, 8, 8, 0, 0, 0, 1, 8, 1, 0, 0, 8, 0, 0, 0, 1, 0, 0], [0, 8, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0], [0, 1, 0, 0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 4, 8, 8, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 8, 1, 0], [0, 0, 0, 0, 4, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 8, 8, 8, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 4, 0, 0, 1, 0, 0, 0, 0], [1, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 8, 0, 0, 0, 0, 4, 8, 4], [0, 8, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 4, 1, 4, 0, 0, 0, 0, 4, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 4, 1, 4], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 8, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 1, 0, 8, 0, 8, 1, 0, 1, 0, 0, 0]]}, "bbb1b8b6": {"instruction": "1. Identify the two 4x4 quadrants in each row group: one on the left and one on the right, separated by a column of 5s.\n2. Ignore (remove) the separating column of 5s.\n3. For each row, extract the four leftmost cells as the left quadrant and the four rightmost cells (after the 5) as the right quadrant. The right quadrant may contain leading or trailing zeros, which are preserved at this step.\n4. Overlay (combine) the right quadrant over the left quadrant using these rules: For each cell in the 4x4 result grid, if the value in the right quadrant at that position is nonzero, use that value; otherwise, use the value from the left quadrant.\n5. Construct the output grid by aligning the overlaid/composited quadrants as a 4x4 grid, preserving their row order.", "test_input": [[1, 1, 1, 1, 5, 2, 0, 0, 0], [0, 1, 1, 0, 5, 2, 2, 2, 2], [0, 1, 1, 0, 5, 2, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0]], "predicted_output": "[[1, 1, 1, 2],\n [0, 1, 1, 2],\n [0, 1, 1, 0],\n [0, 0, 0, 0]]", "expected_output": [[1, 1, 1, 1], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]}, "bbc9ae5d": {"instruction": "1. Take the input grid, which is a single row.\n2. Count the number of contiguous nonzero elements from the start of the row (let this count be N).\n3. Create a new grid with N+1 rows (including the original row as row 0).\n4. For each row i from 1 to N:\n    a. Copy the previous row.\n    b. In row i, set the (N+i-1)th element (counting from 0) to the value of the nonzero elements from the start of the input row.\n5. The process continues until, in the last row, all of the first N+i elements are filled with that value and all remaining elements are zeros.\n6. The final grid is the output grid.", "test_input": [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]]", "expected_output": [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]}, "bc1d5164": {"instruction": "1. Identify the bounding box that encloses all nonzero cells in the input grid.\n2. Divide both the height and width of the bounding box by 2 (using floor division), and extract the 3x3 region at the lower right of the bounding box that is centered with respect to it. (If the box aligns with input borders, this will be in the lower right corner of the bounding box.)\n3. Copy the corresponding values from this 3x3 region to the output grid, preserving their positions within the region.", "test_input": [[0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1]], "predicted_output": "[[0, 0, 0],\n [0, 0, 0],\n [0, 0, 1]]", "expected_output": [[0, 1, 1], [1, 0, 0], [0, 1, 1]]}, "bc4146bd": {"instruction": "1. Identify the input grid as a 4x4 matrix.\n2. For each row in the input grid, create four copies of that row and concatenate them horizontally to form a single new row with 16 columns. For example, if the input row is [A, B, C, D], the resulting row is [A, B, C, D, A, B, C, D, A, B, C, D, A, B, C, D].\n3. Repeat step 2 for each row, so that you have four rows of length 16.\n4. Now, create five vertical segments by splitting each of the new rows into groups of 4 columns, i.e., columns 0-3, 4-7, 8-11, and 12-15.\n5. For each of the four new rows, take each 4-column segment and concatenate them horizontally in the following repeating pattern: take segment 1, then segment 2, then segment 3, then segment 4, then segment 1, then segment 2, etc., until you have a total width of 20 columns.\n6. Stack the four new rows vertically to produce a grid of shape 4x20 as your output.", "test_input": [[5, 5, 4, 4], [5, 5, 5, 2], [2, 5, 5, 5], [5, 5, 2, 4]], "predicted_output": "[[5, 5, 4, 4, 5, 5, 4, 4, 5, 5, 4, 4, 5, 5, 4, 4, 5, 5, 4, 4],\n [5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5, 2],\n [2, 5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5, 2, 5, 5, 5],\n [5, 5, 2, 4, 5, 5, 2, 4, 5, 5, 2, 4, 5, 5, 2, 4, 5, 5, 2, 4]]", "expected_output": [[5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 4, 4, 4, 4, 5, 5, 5, 5, 4, 4], [5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 2], [2, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5, 5, 5, 5, 2, 2, 5, 5, 5], [5, 5, 2, 4, 4, 2, 5, 5, 5, 5, 2, 4, 4, 2, 5, 5, 5, 5, 2, 4]]}, "bc93ec48": {"instruction": "1. Take the leftmost two columns of the input grid and move them to the rightmost two columns, maintaining their original order (the leftmost column becomes the second-to-last, and the second column becomes the last column in each row).\n2. For each row, shift all remaining columns (columns 3 to the end in the original grid) two positions to the left to fill in the vacated positions.\n3. Repeat this transformation for all rows in the grid.", "test_input": [[8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 5, 5], [8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 5, 5], [8, 8, 7, 7, 7, 5, 5, 5, 7, 6, 7, 9, 9, 7, 7, 8], [7, 7, 7, 7, 7, 7, 9, 7, 7, 6, 7, 9, 7, 8, 8, 7], [7, 7, 7, 7, 7, 7, 9, 7, 7, 6, 7, 7, 7, 8, 8, 7], [7, 9, 9, 9, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 3, 3, 3, 3], [7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 2, 2, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7], [1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 8], [1, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8], [1, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8]], "predicted_output": "[[7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 5, 8, 8],\n [7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 5, 8, 8],\n [7, 7, 5, 5, 5, 7, 6, 7, 9, 9, 7, 7, 8, 8, 8, 8],\n [7, 7, 7, 9, 7, 7, 6, 7, 9, 7, 8, 8, 7, 7, 7, 7],\n [7, 7, 7, 9, 7, 7, 6, 7, 7, 7, 8, 8, 7, 7, 7, 7],\n [9, 9, 9, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 3, 3, 3, 7, 7],\n [7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 2, 2, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 6, 7],\n [1, 1, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 8, 1, 1],\n [1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 1, 1],\n [1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 1, 1]]", "expected_output": [[1, 1, 1, 1, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 8], [1, 1, 1, 1, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 8], [1, 1, 1, 1, 7, 5, 5, 5, 7, 6, 7, 9, 9, 7, 8, 8], [7, 7, 7, 7, 7, 7, 9, 7, 7, 6, 7, 9, 7, 8, 8, 7], [7, 7, 7, 7, 7, 7, 9, 7, 7, 6, 7, 7, 7, 8, 8, 7], [7, 9, 9, 9, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 3, 3, 3, 3], [7, 7, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 2, 2, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 7], [8, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 7, 8], [8, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5], [8, 1, 1, 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5]]}, "bcb3040b": {"instruction": "1. For each cell in the grid, examine its value:\n    a. If the cell contains a \"2\", leave it unchanged.\n    b. If the cell contains a \"1\" or \"0\", proceed to the next step.\n2. For every cell in the grid, if it is in the same column or same row as a \"2\" (but is not itself a \"2\"):\n    a. In each such cell, count the total number of \"1\"s in the same row and column as the cell, excluding the cell itself.\n    b. If the cell contains a \"1\", and it is in the same row or column as a \"2\", and it is not already adjacent (up, down, left, right) to a \"2\", then:\n        - Replace its value with \"3\".\n    c. If the cell contains a \"0\", leave it unchanged.\n3. All other cells remain unchanged.", "test_input": [[1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 2], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [2, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]], "predicted_output": "[[3, 3, 0, 3, 0, 3, 0, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 2],\n [3, 3, 0, 0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 3, 3],\n [0, 3, 3, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 3, 0, 0, 0, 0],\n [3, 3, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0, 3, 0, 3, 0, 0, 3],\n [0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n [3, 3, 0, 3, 3, 0, 3, 3, 0, 0, 3, 3, 3, 0, 3, 0, 3, 3],\n [3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 3, 0, 3],\n [3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 0, 0, 3, 3, 3, 3, 3],\n [0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 3, 0, 3, 3, 3, 3, 0, 0],\n [3, 3, 3, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0, 0, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0],\n [0, 0, 3, 3, 3, 0, 3, 3, 0, 0, 0, 3, 3, 0, 3, 3, 3, 3],\n [3, 3, 3, 3, 0, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0, 0, 3],\n [3, 3, 0, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],\n [3, 0, 0, 3, 0, 0, 0, 3, 3, 0, 0, 3, 3, 0, 3, 0, 3, 0],\n [3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 0, 3, 3, 3, 0, 3, 0, 0],\n [3, 3, 0, 0, 0, 3, 0, 3, 0, 0, 3, 0, 0, 3, 0, 3, 3, 3],\n [2, 0, 3, 3, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 3, 0, 0, 0]]", "expected_output": [[1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 2], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 3, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 2, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 3, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 2, 0, 1, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 3, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 3, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0, 0, 2, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 2, 1, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 3, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 3, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 3, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 3, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 1, 3, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 3, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [2, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0]]}, "bd14c3bf": {"instruction": "1. For each row in the input grid, scan for contiguous horizontal lines of cells with value 1 bordered by zeros or the row/column edges.\n2. For every such horizontal line segment of 1s, change every 1 in the segment to 2. Each line segment must be bordered (on the left and right, or at the edge) by zeros or the edge of the grid.\n3. For each vertical column, similarly scan for contiguous vertical lines of cells with value 1 bordered by zeros or the edge.\n4. For every such vertical line segment of 1s, change every 1 in the segment to 2.\n5. All other cell values remain unchanged.", "test_input": [[2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 2, 0, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 2, 0, 2, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 0, 2, 0],\n [2, 2, 2, 2, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 0, 2, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0],\n [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0],\n [0, 2, 2, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0],\n [0, 2, 2, 2, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0],\n [0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0],\n [0, 2, 0, 2, 0, 2, 0, 0, 2, 2, 2, 0, 2, 0, 0, 0, 2, 0, 0],\n [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 2, 0, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [2, 2, 2, 2, 2, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 2, 2, 2, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 2, 2, 2, 2, 2, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 1, 0, 1, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 0, 1, 0, 1, 0, 2, 2, 2, 2, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 0, 1, 1, 1, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "bd283c4a": {"instruction": "1. For each row, starting from the left, set the first five cells (columns 0 to 4) to the most common value found in columns 0 to 4 of the input grid (in this case, '3').\n2. For each row, set columns 5, 6, and 7 (the next three columns) to the most common value found in columns 5 to 7 in the input grid (in this case, '3').\n3. For each row, set column 8 to the most common value found in column 8 of the input grid among all rows (in this case, '8').\n4. For each row, set column 9 (the last column) to the most common value found in column 9 of the input grid among all rows (in this case, '9').", "test_input": [[3, 3, 3, 3, 9, 3, 3, 8, 3, 8], [8, 2, 9, 3, 3, 8, 3, 8, 3, 8], [8, 2, 9, 8, 9, 8, 3, 3, 3, 8], [8, 3, 9, 8, 3, 8, 2, 8, 2, 3], [8, 3, 9, 8, 3, 9, 2, 8, 2, 9], [8, 3, 9, 8, 3, 9, 3, 3, 2, 9], [8, 3, 9, 3, 3, 3, 8, 3, 2, 9], [8, 3, 3, 3, 9, 3, 3, 3, 8, 9], [3, 3, 8, 3, 9, 3, 8, 3, 8, 9], [3, 3, 8, 3, 9, 3, 8, 3, 8, 9]], "predicted_output": "[[3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9],\n [3, 3, 3, 3, 3, 3, 3, 3, 8, 9]]", "expected_output": [[3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 8, 8, 8, 9, 9, 2], [3, 3, 3, 3, 3, 8, 8, 9, 9, 2], [3, 3, 3, 3, 3, 8, 8, 8, 9, 2], [3, 3, 3, 3, 3, 8, 8, 8, 9, 9], [3, 3, 3, 3, 3, 8, 8, 8, 9, 9]]}, "bd4472b8": {"instruction": "1. Copy the first two rows of the input grid to the output grid unchanged.\n2. For the remaining rows, proceed as follows:\n    a. Extract the first row (call it ROW1) from the input grid (excluding the second row).\n    b. For each value in ROW1, create a new row where all elements are filled with that value, matching the input grid's column count.\n    c. Repeat steps a and b, cycling through the elements of ROW1 in order, until all remaining rows of the output grid are filled.\n    d. Fill the output grid rows below the initial two with these new rows in cyclical order, one per row.\n3. Ensure the output grid matches the input grid's size.", "test_input": [[1, 2, 3, 4, 8], [5, 5, 5, 5, 5], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "predicted_output": "[[1, 2, 3, 4, 8],\n [5, 5, 5, 5, 5],\n [1, 1, 1, 1, 1],\n [2, 2, 2, 2, 2],\n [3, 3, 3, 3, 3],\n [4, 4, 4, 4, 4],\n [8, 8, 8, 8, 8],\n [1, 1, 1, 1, 1],\n [2, 2, 2, 2, 2],\n [3, 3, 3, 3, 3],\n [4, 4, 4, 4, 4],\n [8, 8, 8, 8, 8]]", "expected_output": [[1, 2, 3, 4, 8], [5, 5, 5, 5, 5], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [8, 8, 8, 8, 8], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [8, 8, 8, 8, 8]]}, "bd5af378": {"instruction": "1. Identify the input grid, which consists of a block of a constant color (call this the \"main color\", here 3) filling most of the grid, with a side or border (call this the \"frame color\", here 7) on one or more edges.\n2. The last row (bottom edge) is entirely the frame color. The leftmost column is also the frame color, except for the bottom row.\n3. For each cell in the grid, assign new values based on a diagonal pattern:\n   - For the main part of the grid (rows 0 to N-2, columns 1 to N-1), for each row i and column j:\n     - If i + j == N-2, assign the diagonal color (choose a unique \"chain color\", here 8) to cell (i, j).\n     - For lower diagonals, for each k from 1 up to i:\n       - If i + j == N-2 + k, assign the chain color to cell (i, j).\n   - The first diagonal (where i + j == N-2), from top-right towards lower-left, is assigned a different sequence color, e.g., the main color shifted by -1.\n   - The next lower sub-diagonal (i + j == N-2 + 1, etc.) continues with the chain color (here 8).\n4. The rightmost column (column N-1) cycles through the colors from the top to bottom, starting from the frame color except at the bottom row, finishing with the main color.\n5. The leftmost column from row 0 to N-2 becomes the main color, except where interrupted by the diagonal or chain colors.\n6. The bottom row (row N-1) cycles through the main color, except for the last cell, which is the chain color or frame color.\n7. The full construction creates a pattern where the chain (color 8) moves to the right on each row, creating a diagonal with a \"snake\" shape, and the surrounding cells take values of the frame or main color in a specific arrangement, as in earlier examples.\n8. Assign the colors according to the same diagonal/snake logic seen in the examples: main color, chain color, and frame color in their respective new locations.", "test_input": [[7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 3, 3, 3, 3, 3, 3, 3], [7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[7, 3, 3, 3, 3, 3, 3, 2],\n [7, 3, 3, 3, 3, 3, 2, 8],\n [7, 3, 3, 3, 3, 2, 8, 8],\n [7, 3, 3, 3, 2, 8, 8, 8],\n [7, 3, 3, 2, 8, 8, 8, 8],\n [7, 3, 2, 8, 8, 8, 8, 8],\n [7, 2, 8, 8, 8, 8, 8, 8],\n [2, 8, 8, 8, 8, 8, 8, 8],\n [3, 3, 3, 3, 3, 3, 3, 8],\n [7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[3, 7, 8, 8, 8, 8, 8, 8], [3, 7, 8, 8, 8, 8, 8, 8], [3, 7, 8, 8, 8, 8, 8, 3], [3, 7, 8, 8, 8, 8, 3, 8], [3, 7, 8, 8, 8, 3, 8, 8], [3, 7, 8, 8, 3, 8, 8, 8], [3, 7, 8, 3, 8, 8, 8, 8], [3, 7, 3, 8, 8, 8, 8, 8], [3, 8, 7, 7, 7, 7, 7, 7], [8, 3, 3, 3, 3, 3, 3, 3]]}, "bda2d7a6": {"instruction": "1. Identify the three unique colors in the input grid. Let\u2019s call them A (outermost border), B (middle border), and C (innermost filled region). In the given input, A=3, B=7, C=6.\n2. Replace all occurrences of color A (outermost border) with color C.\n3. Replace all occurrences of color B (middle border) with color A.\n4. Replace all occurrences of color C (innermost region) with color B.", "test_input": [[3, 3, 3, 3, 3, 3, 3, 3], [3, 7, 7, 7, 7, 7, 7, 3], [3, 7, 6, 6, 6, 6, 7, 3], [3, 7, 6, 3, 3, 6, 7, 3], [3, 7, 6, 3, 3, 6, 7, 3], [3, 7, 6, 6, 6, 6, 7, 3], [3, 7, 7, 7, 7, 7, 7, 3], [3, 3, 3, 3, 3, 3, 3, 3]], "predicted_output": "[[6, 6, 6, 6, 6, 6, 6, 6],\n [6, 3, 3, 3, 3, 3, 3, 6],\n [6, 3, 7, 7, 7, 7, 3, 6],\n [6, 3, 7, 6, 6, 7, 3, 6],\n [6, 3, 7, 6, 6, 7, 3, 6],\n [6, 3, 7, 7, 7, 7, 3, 6],\n [6, 3, 3, 3, 3, 3, 3, 6],\n [6, 6, 6, 6, 6, 6, 6, 6]]", "expected_output": [[6, 6, 6, 6, 6, 6, 6, 6], [6, 3, 3, 3, 3, 3, 3, 6], [6, 3, 7, 7, 7, 7, 3, 6], [6, 3, 7, 6, 6, 7, 3, 6], [6, 3, 7, 6, 6, 7, 3, 6], [6, 3, 7, 7, 7, 7, 3, 6], [6, 3, 3, 3, 3, 3, 3, 6], [6, 6, 6, 6, 6, 6, 6, 6]]}, "bdad9b1f": {"instruction": "1. Identify all columns containing nonzero elements, specifically columns containing the color 8. In these columns, the 8s are always vertically aligned.\n2. For each such column, extend the column of 8s vertically so that it starts at the top of the grid and ends at the bottom of the grid. Fill in all positions in that column with 8 except where another rule applies (see step 3).\n3. Locate any rows containing at least one 2. For each of these rows, identify the leftmost contiguous block of nonzero values. Replace this block with 2s (preserving their original shape and size).\n4. For the same row containing 2s, immediately to the right of this block, insert a 4 in the column where an 8 would be if the column of 8s were extended as in Step 2.\n5. Fill all remaining positions in that row with 2s to the right of the 4, ensuring the row finishes with only 2s and a single 4 in the column of the 8s.\n6. For all other cells in the grid not already filled by the 8-columns or 2-block/4 row, fill with 0.", "test_input": [[0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 8, 8, 0, 0],\n [0, 0, 8, 8, 0, 0],\n [0, 0, 8, 8, 0, 0],\n [0, 0, 8, 8, 0, 0],\n [2, 2, 8, 4, 2, 2],\n [0, 0, 8, 8, 0, 0]]", "expected_output": [[0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [2, 2, 2, 4, 2, 2], [0, 0, 0, 8, 0, 0]]}, "be03b35f": {"instruction": "1. Locate the 2x2 block in the bottom right corner of the input grid consisting entirely of the value 2. \n2. Identify the 2x2 block directly to the left of this 2x2 block of 2s (i.e., the block made by rows 3 to 4, columns 1 to 2).\n3. Copy this 2x2 block as the output grid, preserving its values and their arrangement.", "test_input": [[1, 1, 0, 0, 1], [0, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 0, 2, 2], [1, 1, 0, 2, 2]], "predicted_output": "[[0, 0],\n [0, 0]]", "expected_output": [[1, 1], [1, 0]]}, "be94b721": {"instruction": "1. Identify all nonzero-colored connected components in the input grid, where a component is a set of adjacent (orthogonally-connected) nonzero cells of the same color. Each component must have at least one cell adjacent (orthogonally) to another cell of the same color.\n2. Among all such components found, locate the component with the lowest color value (if there is a tie, choose the one that appears first when scanning top-to-bottom, left-to-right).\n3. Extract the minimal rectangular bounding box that contains all cells of this lowest-color component.\n4. Copy the contents of this bounding box, preserving the color values and zeroes (if any within the box).\n5. Output the cropped rectangular grid corresponding to this bounding box.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 3, 3, 3, 0, 0, 0], [0, 4, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 5, 5, 5, 0, 0, 6, 6, 6], [0, 5, 5, 0, 0, 0, 6, 6, 0]], "predicted_output": "[[4, 0],\n [4, 4],\n [0, 4]]", "expected_output": [[3, 3, 3], [3, 3, 3], [3, 0, 3], [3, 0, 3]]}, "beb8660c": {"instruction": "1. Identify all nonzero contiguous blocks in each row of the input grid. Each block is a sequence of nonzero numbers aligned horizontally (left to right) that do not include zeros between them.\n2. For each row, record the leftmost and rightmost column indices where each nonzero block appears.\n3. Working from the bottom row upward, place each identified nonzero block into the output grid such that:\n    a. The bottommost nonzero block (from the input's bottom upward) is placed at the bottommost row of the output grid, with the same horizontal position as in the input.\n    b. The next nonzero block (moving upward in the input) is placed in the next row above, maintaining its horizontal column alignment, and so on.\n4. When placing each nonzero block in the output grid, shift the block as far to the right as possible within its row, such that its rightmost nonzero value aligns with the rightmost possible column, while maintaining the original block\u2019s length and composition.\n5. Fill all other cells in the output grid that are not part of a nonzero block with zeros.", "test_input": [[6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 3, 3, 3, 3, 3, 3], [0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 9],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 3],\n [0, 0, 0, 0, 0, 3, 3, 3],\n [0, 0, 0, 0, 3, 3, 3, 3],\n [0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 2, 2, 2],\n [0, 0, 0, 0, 2, 2, 2, 2],\n [0, 0, 0, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 7, 7],\n [0, 0, 0, 0, 0, 4, 4, 4],\n [0, 0, 0, 4, 4, 4, 4, 4],\n [0, 0, 0, 0, 1, 1, 1, 1],\n [0, 0, 0, 6, 6, 6, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 4, 4, 4, 4, 4], [0, 0, 3, 3, 3, 3, 3, 3], [0, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8]]}, "bf32578f": {"instruction": "1. Identify all nonzero cells in the grid. These cells form a symmetric diamond (rhombus) pattern centered within the grid, but only the upper left half is filled.\n2. Determine the bounding box that contains all nonzero cells, i.e., the minimum and maximum rows and columns where nonzero values appear.\n3. Calculate the center row and column of this bounding box.\n4. Based on the distribution of nonzero cells, construct a symmetric diamond (rhombus) shape centered on the previously determined center. The size is chosen so that the shape exactly encloses all original nonzero cells.\n5. Fill all cells within this diamond with the given nonzero value. The interior area should be filled as well, maintaining the symmetry and size.\n6. Set all other cells in the grid (outside this diamond shape) to zero.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 1, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0],\n [0, 1, 1, 1, 1, 1, 0, 0],\n [1, 1, 1, 1, 1, 1, 1, 0],\n [1, 1, 1, 1, 1, 1, 1, 0],\n [0, 1, 1, 1, 1, 1, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0],\n [0, 0, 0, 1, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, "bf699163": {"instruction": "1. Identify all 3x3 square regions in the grid where the center cell is surrounded by 8 cells of the same color (excluding the center), and the center cell is of a different color.\n2. Among these 3x3 regions, select the one whose *outer* (surrounding) color is not the background color (here, not 5).\n3. Copy the 3x3 region, including both outer and center cells, to form the output grid.\n4. In the output grid, replace the center cell with the background color (5), keeping the surrounding color as is.", "test_input": [[5, 5, 5, 5, 5, 5, 5, 5, 7, 5, 2, 2, 2, 5], [5, 5, 6, 6, 6, 5, 5, 5, 7, 5, 2, 5, 2, 5], [5, 5, 6, 5, 6, 5, 5, 5, 7, 5, 2, 2, 2, 5], [5, 5, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 5, 5, 7, 7], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 5, 8, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 8, 8, 8, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 1, 5, 1, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5]], "predicted_output": "[[8, 8, 8],\n [8, 5, 8],\n [8, 8, 8]]", "expected_output": [[2, 2, 2], [2, 5, 2], [2, 2, 2]]}, "bf89d739": {"instruction": "1. For each row in the grid, identify the positions of all cells containing the value 2.\n2. For each such position, starting from the topmost row and proceeding row by row:\n    a. In the same column, move downward to the next occurrence of a 2 (or to the edge of the grid if there are no further 2s below). \n    b. Between this 2 and the next (or the edge of the grid), replace all 0s in that column with 3, except for the rows containing the 2s themselves, which remain 2.\n    c. Repeat this process for each group of vertically aligned 2s in a column.\n3. If more than one column contains a 2 in the same row, then consider the horizontal region between the outermost 2s on that row. Fill all cells between the 2s (in that row) with 3.\n4. For each new 2 encountered in any column, repeat the filling procedure between it and the following 2 or the edge of the grid, both vertically and, when applicable, horizontally as described.\n5. Leave all other cells unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 3, 3, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 0, 0, 3, 3, 0, 0, 0],\n [0, 3, 0, 0, 2, 0, 3, 0, 3, 0, 3, 0, 3, 3, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 3, 0, 0, 0],\n [0, 2, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 2, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 2, 0, 3, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 3, 0, 2, 0, 3, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c074846d": {"instruction": "1. Locate the position of the cell containing the value 5 (the \"anchor\" point).\n2. Identify all cells in the same column above the 5 that contain the value 2. Replace each of these 2s with the value 3.\n3. Starting from the row of the 5 and moving upward, in the same column, shift the position of the sequence of 2s (now changed to 3s) one column to the left, so that each occupies the cell immediately to the left of its previous position.\n4. In the same column as the original 2s, fill all cells above the row containing the 5 (that formerly contained 2s) with 0 (erase them).\n5. In the new column (one left of the original cluster), fill the cells from the row above the 5 upwards (as many as there were original 2s) with the value 2, directly aligned with where the original 2s were, but shifted left.\n6. Leave all other cells unchanged.", "test_input": [[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c0f76784": {"instruction": "1. Identify all distinct rectangular regions in the grid that are bounded by the color 5 forming a closed rectangle or almost-closed shape with empty (0) cells inside.\n2. For each such rectangle, fill the entire interior (excluding the boundary of 5s) with a unique nonzero color according to its position:\n   - For the upper-left rectangle, fill with color 8 if present.\n   - For the rectangle in the right part of the lower section, fill with color 7 if present.\n   - For the rectangle in the upper-left part of the output, if it is a square with all 5s and a single cell in the center surrounded by 5s, fill that cell with color 6.\n   - Otherwise, follow the observed color mapping sequences for filling (i.e., top groupings use 8, lower groupings use 7, or 6 as appropriate).\n3. If a filled rectangle overlaps with more than one color region, split the regions according to the boundaries defined by the 5s, and fill each separate interior with the appropriate color.\n4. Leave all other cells (background or 5 boundaries) unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 0, 0, 5, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0],\n [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0],\n [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0],\n [0, 5, 8, 8, 8, 5, 0, 0, 5, 5, 5, 0],\n [0, 5, 5, 5, 5, 5, 0, 0, 5, 7, 5, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 5, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0],\n [0, 0, 0, 0, 5, 6, 6, 5, 0, 0, 0, 0],\n [0, 0, 0, 0, 5, 6, 6, 5, 0, 0, 0, 0],\n [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 0, 0, 5, 6, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0]]}, "c1990cce": {"instruction": "1. Let N be the length of the input grid (number of columns). Create an output grid with N rows and N columns, initializing all cells to 0.\n2. Copy the input row as the first row of the output grid.\n3. For each subsequent row k (starting from 1 up to N-1):\n    a. For each cell at column j in row k:\n        i. If there is a '2' at column m in row k-1, and |j - m| = 1 (i.e., immediately left or right of a previous '2'), set output[k][j] to 2.\n        ii. If there is a '1' at columns (j-1) and (j+1) in row k-1, set output[k][j] to 1.\n        iii. For k \u2265 N//2, in addition to the above, set output[k][j] to 1 if both output[k-1][j-1] and output[k-1][j+1] are 1.\n        iv. Otherwise, leave output[k][j] as 0.\n4. Continue until all N rows are completed.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0],\n [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0], [0, 2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0], [2, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]]}, "c1d99e64": {"instruction": "1. For each row in the grid, check if **all** elements in that row are equal to 0.\n2. If a row meets this condition (i.e., is entirely filled with 0s), replace **every element** in that row with the value 2.\n3. For all other rows, do not change any of the elements; leave them as they are.", "test_input": [[4, 0, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 0, 4, 0, 0], [4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 0], [4, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4], [4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0], [0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 0, 4], [4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 4, 4, 0, 0, 4, 4, 4], [4, 0, 4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4], [4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 0, 4, 4], [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4], [0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0], [0, 4, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4], [4, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 0, 0, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0, 4, 4, 4, 0, 4, 4, 4], [0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 4, 0], [4, 0, 4, 0, 4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 0, 4, 0], [4, 4, 0, 4, 0, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 4, 0, 4, 0, 4, 4, 4], [4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4]], "predicted_output": "[[4, 0, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 0, 4, 0, 0],\n [4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 0],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [4, 0, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 0],\n [4, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4],\n [4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 0, 4],\n [4, 0, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4],\n [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0],\n [0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 0, 4],\n [4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 4, 4, 0, 0, 4, 4, 4],\n [4, 0, 4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4],\n [4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [0, 4, 4, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 0, 4, 4],\n [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 0, 4, 4, 4],\n [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4],\n [0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0],\n [0, 4, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4],\n [4, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0],\n [4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 0, 0, 4, 4],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0, 4, 4, 4, 0, 4, 4, 4],\n [0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 0, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 4, 0],\n [4, 0, 4, 0, 4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 0, 4, 0],\n [4, 4, 0, 4, 0, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 4, 0, 4, 0, 4, 4, 4],\n [4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4]]", "expected_output": [[4, 0, 4, 0, 4, 4, 2, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 2, 4, 0, 0], [4, 4, 4, 0, 0, 4, 2, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 2, 4, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 0, 4, 4, 4, 0, 2, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 0], [4, 4, 0, 4, 4, 4, 2, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 2, 4, 4, 4], [4, 4, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 2, 4, 0, 4], [4, 0, 0, 4, 0, 4, 2, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 0, 2, 4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 2, 0, 4, 0], [0, 4, 4, 0, 4, 4, 2, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 0, 2, 4, 0, 4], [4, 4, 4, 0, 4, 4, 2, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 4, 4, 0, 2, 4, 4, 4], [4, 0, 4, 4, 4, 0, 2, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 2, 0, 0, 4], [4, 4, 0, 4, 0, 0, 2, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 2, 4, 4, 4], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 4, 4, 0, 0, 0, 2, 0, 4, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 2, 0, 4, 4], [4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 0, 2, 4, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 2, 4, 0, 4], [0, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 2, 4, 4, 0], [0, 4, 4, 4, 4, 0, 2, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 2, 0, 4, 4], [4, 4, 4, 0, 4, 4, 2, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0, 0, 0], [4, 4, 0, 4, 4, 4, 2, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 2, 0, 4, 4], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 0, 4, 2, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0, 4, 4, 4, 2, 4, 4, 4], [0, 4, 4, 4, 4, 4, 2, 4, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 4, 2, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 0, 4, 4, 4, 2, 4, 4, 0], [4, 0, 4, 0, 4, 4, 2, 4, 0, 0, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 2, 0, 4, 0], [4, 4, 0, 4, 0, 4, 2, 0, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 4, 0, 4, 2, 4, 4, 4], [4, 0, 0, 4, 4, 4, 2, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 0, 2, 4, 4, 4]]}, "c61be7dc": {"instruction": "1. Identify all columns where every row has a '0' at the same position. In all provided examples, these are 'divider columns' that separate regions.\n2. For every non-divider column, shift all elements in that column down by one row, wrapping the last element to the top, **but only if that row, before the shift, did not contain a complete horizontal line of '0's (a \"separator row\")**. If there is a horizontal separator of zeros, do not shift columns in those rows, just keep them as zeros.\n3. For every region between vertical divider columns, replace its content so that, between each pair of vertical dividers, all rows except for the all-zero separator rows contain one column set to 5 (in the center of the region), all other positions (excluding the divider columns and the separator rows) set to 7, and two columns on either side of the 5 set to 0 (i.e., 7 0 5 0 7 for a 5-wide region).\n4. Keep the divider columns of zeros unchanged in every row.\n5. Keep the separator rows of zeros unchanged.", "test_input": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 0, 5, 0, 7, 0, 5, 0, 7, 0, 7, 0, 5, 0, 7, 0, 5, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 5, 0, 7, 0, 5, 0, 5, 0, 5, 0, 5, 0, 7, 0, 5, 0, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7],\n [7, 0, 0, 0, 7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 7]]", "expected_output": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7]]}, "c62e2108": {"instruction": "1. Identify all contiguous shapes in the grid that are formed by nonzero numbers (other than 0). Each shape represents a block that is outlined by 1s and filled with a nonzero value (such as 4), or is a row or rectangle of 1s.\n2. For each block (shape) outlined by 1s and filled with another color:\n    a. Remove the 1s outlining the shape.\n    b. Copy the filled pattern (the block with the inner nonzero color value) to positions where the original outline of 1s existed, extending the pattern as necessary so that what was previously a 1-outline becomes now the filled block itself.\n    c. If you have two shapes horizontally apart in the same row, create new blocks for the expanded area in the output.\n3. Repeat this process for every instance where there is an outline and an inner filled shape in the grid (in both the upper and lower rows as necessary).\n4. Leave any parts of the grid that contained only 0s untouched.", "test_input": [[0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0]]}, "c64f1187": {"instruction": "1. Identify all nonzero colored elements (excluding 1s and 5s) in the second row of the input grid. For each such colored element, extract a vertical block consisting of each such element and the \"descending staircase\" of 1s that appears immediately below it. The staircase of 1s starts directly under the colored element, either as a single column or as two or more consecutive 1s aligned diagonally downward, matching the \"stair\" pattern. Extend this block to the lowest row containing 1s in the staircase for this column group.\n2. For each extracted staircase block, transform it as follows: \n    a. For the colored element at the top, create a new 2x2 square in the output grid filled with that color. Place the square starting at the corresponding position in the output (not necessarily the same position as in the input).\n    b. For the 1s of the staircase immediately under the colored element, assign an identical color 2x2 square in the output, aligned below or diagonally below as per the original arrangement. \n    c. Continue following the staircase structure, filling 2x2 blocks accordingly and using the color found at the top of the original staircase.\n3. After processing all colored elements and their staircases from step 1, go to the block of rows where there are horizontal repetitions of the 5s pattern with interspersed colored elements (spanning typically several groups of 2x2 blocks). Extract these regions as distinct components for the output, using the nonzero colored element(s) in this region as the basis for new blocks.\n4. For each identified component with colored elements in the \"5s blocks\":\n    a. If a colored element appears in the lower row of a double row with 5s (i.e., a pair like [5, X] above [5, Y], where X or Y is a nonzero color), create a 2x2 block with the color of that element for the output.\n    b. For colored elements that appear alone in a column, output a 2x2 block of that color at the corresponding position in the output grid.\n    c. Ignore plain blocks with only 5s (these do not appear in the output).\n5. Combine all blocks created from steps 2 and 4 to form the final output grid in compressed form (remove empty rows and columns between blocks), preserving block order from left to right and grouping blocks vertically per the structure in the input (i.e., the order in which the blocks appear vertically).\n6. Fill all remaining cells with 0 unless already set by a colored block.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 2, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 2, 0, 5, 2, 0, 5, 2, 0, 5, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 3, 0, 5, 3, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 4, 0, 5, 3, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 4, 0, 5, 5, 0, 5, 5, 0, 5, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4],\n [2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4],\n [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1],\n [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1],\n [2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4],\n [2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4],\n [2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4],\n [2, 2, 0, 8, 8, 0, 3, 3, 0, 4, 4]]", "expected_output": [[2, 2, 0, 2, 2, 0, 2, 2, 0, 8, 8], [2, 0, 0, 2, 0, 0, 2, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 3, 3, 0, 0, 0, 0, 0, 0], [4, 4, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 8], [4, 4, 0, 0, 0, 0, 0, 0, 0, 8, 8]]}, "c658a4bd": {"instruction": "1. Locate the largest nonzero rectangular or boxed structure (characterized by a color other than 0) in the input grid. This is the main figure to extract. The structure can be a rounded square, rectangle, or box outlined by color, or filled, in the input.\n2. Crop the grid to this main structure, removing all rows and columns on the outside that consist entirely of 0s. The cropped region should tightly fit the non-background pattern.\n3. Identify the main outer boundary color (the color outlining the outermost layer of the cropped figure) and replace it with a new color, according to the mapping seen in examples.\n    - In the first example, the outer color 3 became the border in the output.\n    - In the second, the outer color 2 became the border in the output.\n    - For the test, use the color of the thickest (outermost) contiguous border as the output border color.\n4. Identify the second layer (just inside the border) of contiguous color, and recolor it to the correct secondary border color as in the examples (e.g., 8 in first and second examples).\n5. Continue peeling layers:\n    - For each new inner border or major distinct figure within the shape, recolor according to the same logic as in the examples: for example, inner rounded rectangles or boxes and their fills are mapped to new colors in a consistent way.\n    - For inner structures such as a central \u201cface\u201d or \u201cpatch,\u201d map each color region to its new color as per pattern; in previous examples, specific central features (like a group of 1's, or 4's, or 3's) consistently map to their respective positions/colors in the output, preserving structure.\n6. Ensure that interior features (patterns, numbers, or arrangements inside the layers) are maintained in their relative spatial relations within the cropped region, but recolored as per the observed transformation rules.\n7. Output the fully transformed, recolored, and cropped grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 2, 2, 0, 0], [0, 0, 6, 0, 8, 8, 8, 8, 8, 8, 0, 6, 0, 0, 0, 2, 2, 0, 0], [0, 0, 6, 0, 8, 0, 0, 0, 0, 8, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 8, 3, 3, 3, 3, 8, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 8, 3, 0, 0, 0, 8, 0, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 8, 3, 0, 0, 0, 8, 0, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 8, 8, 8, 8, 8, 8, 0, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 3, 0, 0, 0, 0, 0, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 3, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 2, 2],\n [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 2, 2],\n [6, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 6, 0, 0, 0, 0, 0],\n [6, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 6, 0, 0, 0, 0, 0],\n [6, 0, 8, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 0, 0, 0, 0],\n [6, 0, 8, 3, 0, 0, 0, 8, 0, 6, 3, 0, 0, 0, 0, 0, 0],\n [6, 0, 8, 3, 0, 0, 0, 8, 0, 6, 3, 0, 0, 0, 0, 0, 0],\n [6, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 6, 3, 0, 0, 0, 0],\n [6, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 6, 3, 0, 0, 0, 0],\n [6, 6, 6, 3, 6, 6, 6, 6, 6, 6, 6, 6, 3, 0, 0, 0, 0],\n [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0]]", "expected_output": [[6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 3, 3, 3, 3, 3, 3, 3, 3, 6], [6, 3, 8, 8, 8, 8, 8, 8, 3, 6], [6, 3, 8, 4, 4, 4, 4, 8, 3, 6], [6, 3, 8, 4, 2, 2, 4, 8, 3, 6], [6, 3, 8, 4, 2, 2, 4, 8, 3, 6], [6, 3, 8, 4, 4, 4, 4, 8, 3, 6], [6, 3, 8, 8, 8, 8, 8, 8, 3, 6], [6, 3, 3, 3, 3, 3, 3, 3, 3, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6]]}, "c6e1b8da": {"instruction": "1. For each nonzero region in the grid, identify contiguous blocks of the same color, horizontally and vertically connected.\n2. For each colored block that is surrounded by another color block of the same primary color but a different fill (i.e., if the block is embedded within a thicker or larger version of the same color area, such as the \"core\" in the middle of a colored \"frame\"), expand that embedded block's outermost color to replace the outer shell of its enclosing color, merging the entire region into a solid block. Specifically, shrink the \"thick shell\" regions to match the width of the embedded \"core\" (for example, if there is a block of thickness 3, reduce it to thickness 1 around the same center).\n3. In each horizontal band of color, if there are any extraneous horizontal extensions or appendages (such as stripes or protrusions extending away from the main mass), remove these so that colored bands are as vertically and horizontally compact as possible, centered in the position where the main density of that color appears.\n4. If a region of one color is combined with protrusions or branches of the same color in other locations nearby, consolidate these into a single contiguous block in line with the new \"compact\" main block, removing the disconnected appendages.\n5. Apply this process for every distinct color in the grid. The result should be that all colored regions are compacted to their core contiguous mass, with extraneous extensions or shells removed, resulting in \"fatter\" or \"thicker\" bands becoming uniformly \"thinner\" and all colored regions being contiguous only within their primary area.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c7d4e6ad": {"instruction": "1. For each row in the input grid, identify the unique nonzero color (other than 5) present in the first nonzero column of that row. This is the \"main color\" for that row.\n2. For all cells in the row that contain a 5, replace the 5 with the \"main color\" identified for that row.\n3. Leave all other values (including zeros and other nonzero numbers that are not 5) unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 5, 5, 0, 5, 0, 0], [2, 0, 0, 5, 5, 5, 5, 5, 0, 0], [3, 0, 0, 5, 0, 0, 0, 0, 0, 0], [3, 0, 0, 5, 5, 5, 0, 0, 0, 0], [3, 0, 0, 0, 0, 5, 0, 0, 0, 0], [4, 0, 0, 5, 5, 5, 5, 0, 0, 0], [7, 0, 0, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 2, 2, 0, 2, 0, 0],\n [2, 0, 0, 2, 2, 2, 2, 2, 0, 0],\n [3, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n [3, 0, 0, 3, 3, 3, 0, 0, 0, 0],\n [3, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n [4, 0, 0, 4, 4, 4, 4, 0, 0, 0],\n [7, 0, 0, 7, 7, 7, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 2, 2, 0, 2, 0, 0], [2, 0, 0, 2, 2, 2, 2, 2, 0, 0], [3, 0, 0, 3, 0, 0, 0, 0, 0, 0], [3, 0, 0, 3, 3, 3, 0, 0, 0, 0], [3, 0, 0, 0, 0, 3, 0, 0, 0, 0], [4, 0, 0, 4, 4, 4, 4, 0, 0, 0], [7, 0, 0, 7, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c803e39c": {"instruction": "1. Divide the input grid vertically into equal-width blocks, using columns of 5s (value 5) as the separators. Ignore any outer padding of zeros beyond the first and last block.\n2. For each block, remove all zero values and form a new, compact rectangle containing only the non-zero numbers; preserve their relative positions, and ignore columns/rows that are entirely zeros.\n3. Place all the compacted blocks together into a new larger grid by aligning them consecutively from left to right (preserving their order from left to right in the input). Do not put gaps or separators between the blocks.\n4. Combine the compacted blocks into a single large grid. If the blocks have different heights, pad the bottom of shorter blocks with their most frequent value until all are the same height as the tallest block.\n5. The final output grid consists of these combined, compacted, and padded blocks.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 5, 0, 2, 2, 2, 2, 2, 0, 5, 0, 3, 3, 3, 3, 3, 0, 5, 0, 4, 4, 4, 4, 4], [0, 1, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 2, 0, 5, 0, 3, 3, 3, 3, 3, 0, 5, 0, 4, 4, 4, 4, 4], [0, 1, 1, 1, 1, 1, 0, 5, 0, 2, 2, 2, 2, 2, 0, 5, 0, 3, 3, 3, 3, 3, 0, 5, 0, 4, 4, 4, 4, 4], [0, 0, 0, 1, 0, 1, 0, 5, 0, 2, 0, 0, 0, 0, 0, 5, 0, 3, 3, 3, 3, 3, 0, 5, 0, 4, 4, 4, 4, 4], [0, 0, 0, 1, 1, 1, 0, 5, 0, 2, 2, 2, 2, 2, 0, 5, 0, 3, 3, 3, 3, 3, 0, 5, 0, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n [1, 0, 1, 0, 1, 0, 2, 0, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n [1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n [0, 1, 0, 1, 0, 2, 0, 0, 0, 0, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n [0, 1, 1, 1, 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]]", "expected_output": [[3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4], [3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3], [4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 3], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3], [3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4], [3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3], [4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3], [3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 3, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4], [3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3, 4, 4, 3, 4, 3], [4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3, 4, 4, 3, 3, 3]]}, "c87289bb": {"instruction": "1. Identify the block(s) of contiguous nonzero cells (specifically, the '2' color) in the lower half of the grid (below the repeated banded pattern of '8's at the top). Determine the rows and columns spanned by these blocks.\n2. For each column that contains at least one '2' in the lower half, identify the corresponding \"pillar\" in the upper part of the grid: these are columns that have at least one '8' in the rows above the first row containing a '2'.\n3. Starting from the first row that is above the first '2' row, for as many rows as needed to fill out a rectangle equal in height to the number of rows beneath (including and below) the first '2' row, fill all positions in each identified \"pillar\" column above with '8's.\n4. In other words, form a solid rectangle of '8's in every column participating in the '2' block, from the first row above the '2' block down to the bottom of the grid, except where the original '2's are already present (leave those as '2').\n5. Copy the rest of the grid as-is, except where it's overwritten by the filled rectangles of '8's as described above.", "test_input": [[0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0],\n [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0],\n [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0],\n [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0],\n [0, 8, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0],\n [0, 8, 0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0],\n [0, 8, 0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0],\n [0, 8, 0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0],\n [0, 8, 0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0],\n [0, 8, 0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0]]", "expected_output": [[0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0], [0, 8, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0, 0, 8, 8], [0, 8, 0, 8, 2, 2, 0, 8, 0, 8, 2, 2, 2, 2, 8], [0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8], [0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8], [0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8], [0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8], [0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 8]]}, "c8b7cc0f": {"instruction": "1. Identify all non-zero values in the input grid. Find the minimal bounding rectangle that contains all cells with the same non-zero value (excluding '1's if present; in each provided example, a unique non-background non-1 color is used: 6, 4, 3, or 2).\n2. For that chosen color, create a new 3x3 grid. Fill the first row entirely with this color.\n3. Fill the first cell of the second row with this color, leaving the rest as 0.\n4. Fill the first two cells of the third row with 0, so the lower right cell is also 0.\n5. For any remaining cells, fill with 0.", "test_input": [[2, 0, 0, 0, 0, 0, 2, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 2, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 2, 0, 1, 2, 0], [1, 0, 0, 0, 0, 2, 1, 0, 0], [1, 2, 0, 0, 0, 0, 1, 0, 2], [1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0]], "predicted_output": "[[2, 2, 2],\n [2, 0, 0],\n [0, 0, 0]]", "expected_output": [[2, 2, 2], [2, 0, 0], [0, 0, 0]]}, "c8cbb738": {"instruction": "1. Identify all cells in the input grid that contain a value different from the background value (the background is 8 in this case).\n2. Find the minimum and maximum row and column indices among these non-background cells.\n3. Define a bounding box that tightly encloses all the non-background cells, using the min and max row/col indices.\n4. Extract the subgrid defined by this bounding box from the original grid.\n5. Output this extracted subgrid as the final grid.", "test_input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 8], [8, 8, 8, 3, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 8, 6, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 8, 8, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 8, 6, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "predicted_output": "[[1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [1, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 8],\n [1, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 8],\n [8, 3, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 6, 8, 6, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 3, 8, 8, 8, 3, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 6, 8, 6, 8, 8, 8]]", "expected_output": [[3, 8, 6, 1, 6, 8, 3], [8, 8, 8, 8, 8, 8, 8], [2, 8, 8, 8, 8, 8, 2], [1, 8, 8, 8, 8, 8, 1], [2, 8, 8, 8, 8, 8, 2], [8, 8, 8, 8, 8, 8, 8], [3, 8, 6, 1, 6, 8, 3]]}, "c8f0f002": {"instruction": "1. Scan the input grid for all occurrences of the color/value 7.\n2. Replace every cell containing the value 7 with the value 5.\n3. Leave all other cell values unchanged.", "test_input": [[1, 7, 7, 1, 7], [8, 1, 7, 7, 7], [8, 7, 1, 7, 8]], "predicted_output": "[[1, 5, 5, 1, 5],\n [8, 1, 5, 5, 5],\n [8, 5, 1, 5, 8]]", "expected_output": [[1, 5, 5, 1, 5], [8, 1, 5, 5, 5], [8, 5, 1, 5, 8]]}, "c909285e": {"instruction": "1. Locate the central unique 7x7 block within the larger input grid. This block is bordered by a different surrounding \"frame\" color and contains the key content. Its top-left corner can be identified by searching for a 7x7 area containing unique data that does not fully match the repeated pattern or background in the rest of the grid.\n2. Extract this 7x7 block and treat it as the main content for the output grid.\n3. Copy this 7x7 block to the output grid, preserving its values and structure.", "test_input": [[0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2, 2, 2, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2, 2, 2, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 8, 2, 2, 4, 2, 8, 2, 2, 2, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 8, 2, 0, 4, 0, 8, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 8, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 8, 2, 0, 4, 0, 8, 1, 0, 0, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "predicted_output": "[[3, 3, 8, 8, 8, 8, 8],\n [2, 2, 8, 2, 2, 4, 2],\n [0, 0, 8, 2, 0, 4, 0],\n [4, 4, 8, 4, 4, 4, 4],\n [0, 0, 8, 2, 0, 4, 0],\n [3, 3, 8, 8, 8, 8, 8],\n [1, 1, 3, 2, 1, 4, 1]]", "expected_output": [[8, 8, 8, 8, 8, 8], [8, 2, 2, 4, 2, 8], [8, 2, 0, 4, 0, 8], [8, 4, 4, 4, 4, 8], [8, 2, 0, 4, 0, 8], [8, 8, 8, 8, 8, 8]]}, "c920a713": {"instruction": "1. Identify the smallest bounding box in the input grid that contains all the non-background (non-zero) cells. This bounding box will define the core region of interest.\n2. Extract this bounding box to form a subgrid, effectively cropping out any zero (background) rows or columns from the borders.\n3. Within this extracted subgrid, identify the structure made of \"frames\" of colors. The outermost frame is the first layer, the next inner frame is the second layer, and so on, toward the center.\n4. Remap the color values according to the layer they appear in:\n    - Set the outermost frame's color to a specific value (from training examples: first frame = 2).\n    - Set the next inner frame's color to the next specified value (second frame = 4).\n    - Continue mapping inner frames using a pattern derived from the training examples (third frame = 3, then 9, then 7, then [center] 5, etc.).\n    - For any distinct inner elements (e.g., center special marks), use the mapped center value.\n5. Redraw these frames as concentric layers with uniform color as specified by the mapping, preserving the input\u2019s original frame shapes but overwriting any interior patterns with the correct solid color.\n6. Ensure each frame is a solid border with the given mapped color, and corners are filled according to the mapped color of that layer.\n7. The output grid should be a perfect square (or rectangle if the non-background region isn't square), with each layer reflecting the correct color as per the mapping for that layer across all examples.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 2, 5, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0], [0, 0, 0, 0, 0, 1, 3, 0, 5, 0, 1, 0, 0, 6, 0, 0, 0, 0, 8, 0, 5, 6, 0, 8, 0], [0, 0, 0, 0, 0, 1, 3, 0, 5, 5, 1, 5, 5, 6, 5, 5, 5, 5, 5, 5, 5, 6, 0, 8, 0], [0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 1, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 6, 0, 8, 0], [0, 0, 0, 0, 0, 1, 3, 3, 3, 3, 1, 3, 3, 6, 3, 3, 3, 3, 8, 0, 0, 6, 0, 8, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 4, 4, 4, 6, 4, 4, 0, 0, 8, 8, 8, 6, 8, 8, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 1, 0, 0, 6, 0, 4, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 4, 4, 4, 4, 6, 4, 4, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2],\n [2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2],\n [2, 4, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 3, 4, 2],\n [2, 4, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 3, 4, 2],\n [2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2],\n [2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]", "expected_output": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [2, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2], [2, 3, 8, 5, 5, 5, 5, 5, 5, 5, 8, 3, 2], [2, 3, 8, 5, 1, 1, 1, 1, 1, 5, 8, 3, 2], [2, 3, 8, 5, 1, 4, 4, 4, 1, 5, 8, 3, 2], [2, 3, 8, 5, 1, 4, 6, 4, 1, 5, 8, 3, 2], [2, 3, 8, 5, 1, 4, 4, 4, 1, 5, 8, 3, 2], [2, 3, 8, 5, 1, 1, 1, 1, 1, 5, 8, 3, 2], [2, 3, 8, 5, 5, 5, 5, 5, 5, 5, 8, 3, 2], [2, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 2], [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}, "c92b942c": {"instruction": "1. For each cell in the input grid, create a 3x3 block in the output grid, so that the output grid has dimensions (input_rows * 3) x (input_cols * 3).\n2. For every cell in the input, fill its corresponding 3x3 block in the output as follows:\n    a. If the input cell contains 0:\n        - All cells in the 3x3 block should be 0, except for the cell at (0,1) and (2,1) (i.e., center cells of the left and right columns of the block), which should be 3.\n    b. If the input cell is nonzero (value V):\n        - Set the pattern for the 3x3 block as:\n            [[1, V, 1],\n             [1, V, 1],\n             [1, V, 1]]\n3. Repeat this block placement for all cells, so every cell in the input is expanded to a 3x3 patterned block in the output at position (row*3, col*3).", "test_input": [[2, 0, 0], [0, 0, 0], [0, 0, 0]], "predicted_output": "[[1, 2, 1, 0, 3, 0, 0, 3, 0],\n [1, 2, 1, 0, 0, 0, 0, 0, 0],\n [1, 2, 1, 0, 3, 0, 0, 3, 0],\n [0, 3, 0, 0, 3, 0, 0, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 0, 3, 0],\n [0, 3, 0, 0, 3, 0, 0, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 0, 0, 3, 0, 0, 3, 0]]", "expected_output": [[2, 1, 1, 2, 1, 1, 2, 1, 1], [0, 3, 0, 0, 3, 0, 0, 3, 0], [0, 0, 3, 0, 0, 3, 0, 0, 0], [2, 1, 1, 2, 1, 1, 2, 1, 1], [0, 3, 0, 0, 3, 0, 0, 3, 0], [0, 0, 3, 0, 0, 3, 0, 0, 0], [2, 1, 1, 2, 1, 1, 2, 1, 1], [0, 3, 0, 0, 3, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c9680e90": {"instruction": "1. Identify the horizontal line consisting of all 9s (the separator row).\n2. For each cell above the separator row:\n    a. If a cell contains a 5, move it directly left to the nearest cell containing 7 within the same row. Replace the original 5 with 7.\n    b. If there are multiple 5s in a row, process each one independently as above.\n3. For each cell below the separator row:\n    a. If a cell contains a 2, move it directly left to the nearest cell containing 7 within the same row. Replace the original 2 with 7.\n    b. If there are multiple 2s in a row, process each one independently as above.\n4. All other cells (including 6s and the separator row) remain unchanged.", "test_input": [[7, 7, 7, 7, 7, 7, 7, 5, 7, 5, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 5], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 2, 7, 7, 7, 7, 6, 6, 2], [7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 2, 6, 6, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 6, 6, 6, 6, 2, 7, 2, 6]], "predicted_output": "[[7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9],\n [2, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7],\n [7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 2, 6, 6, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [6, 7, 7, 7, 6, 6, 6, 7, 7, 2, 7]]", "expected_output": [[7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 5], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7], [7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 7, 7, 7, 7, 2, 7, 7], [7, 7, 7, 2, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 2, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 2, 7, 7, 7, 7, 7, 7, 2]]}, "c97c0139": {"instruction": "1. Identify all contiguous horizontal and vertical lines that are made up of nonzero cells (with value 2) in the input grid. Each such group defines the \"base\" of a diamond to be drawn. \n2. For each such line (segment of 2's), draw a diamond shape of value 8 centered on the line, with the size and symmetry implied by the length and orientation of the line:\n   a. If the segment is horizontal, grow a diamond vertically above and below the segment. The middle point(s) of the segment determine the widest row of the diamond. For rows above and below the segment, reduce the width toward one cell for each row further from the central segment.\n   b. If the segment is vertical, grow a diamond horizontally to the left and right, with the same logic.\n3. Overlap diamonds as needed, but do not overwrite existing 2's with 8's\u2014the 2's remain as is.\n4. All other cells remain unchanged from the input grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 8, 8, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 8, 2, 2, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [8, 8, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 8, 2, 2, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 8, 8, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 8, 2, 2, 2, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 0, 8, 2, 8, 0, 8, 8, 8, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 8, 2, 2, 8, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 0],\n [0, 0, 8, 2, 2, 2, 8, 0, 8, 8, 8, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 0],\n [0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 8, 8, 2, 2, 2, 8, 8, 8, 8, 8, 8, 0],\n [8, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 8, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 8, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 8, 2, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 2, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "c9e6f938": {"instruction": "1. For each row in the input grid, horizontally duplicate the row by appending a reversed version of the row (excluding the first element to avoid double-counting the center cell if the grid has an odd width).\n2. For each column in the new grid, set the last element of the column (i.e., last cell in each row) to match the first element of that column, effectively mirroring the column values (excluding the center if odd-length).\n3. Repeat this mirroring for every row to create a horizontally symmetric grid with double the original width.\n4. Fill all new cells with 0, except where values are copied by mirroring as described.", "test_input": [[7, 7, 0], [0, 7, 0], [0, 0, 7]], "predicted_output": "[[7, 7, 0, 7, 7],\n [0, 7, 0, 7, 0],\n [0, 0, 7, 0, 0]]", "expected_output": [[7, 7, 0, 0, 7, 7], [0, 7, 0, 0, 7, 0], [0, 0, 7, 7, 0, 0]]}, "c9f8e694": {"instruction": "1. For each row in the grid, identify all cells that contain the value 5.\n2. For each contiguous horizontal segment of 5s in the row, replace every 5 in that segment with the value of the first nonzero cell in the same row (i.e., the leftmost nonzero value in that row).\n3. Leave all other values in the grid unchanged.", "test_input": [[1, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [8, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [1, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [1, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [7, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [8, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0]], "predicted_output": "[[1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],\n [8, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0],\n [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],\n [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],\n [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7],\n [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7],\n [7, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7],\n [7, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0],\n [8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0],\n [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0],\n [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0],\n [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0]]", "expected_output": [[1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [8, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7], [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7], [7, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7], [7, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0]]}, "ca8de6ea": {"instruction": "1. Remove the outermost rows and columns from the input grid, resulting in a 3x3 grid that contains only the inner rows and columns.\n2. For each cell in the resulting 3x3 grid, replace it with the nonzero value from the corresponding row and/or column in the original grid (using the original grid\u2019s pattern):\n   - Top row: Use the leftmost nonzero element from the corresponding trimmed row for the first column, the center nonzero for the center column, and the rightmost nonzero for the last column.\n   - Middle row: Use the leftmost nonzero for the first column, the center nonzero for the center column, and the rightmost nonzero for the last column.\n   - Bottom row: Same logic as above.\n   (Alternatively, more simply: keep only nonzero entries from the original grid, and for each row and column in the trimmed 3x3, fill as in the original pattern.)\n3. The final 3x3 grid is your output.", "test_input": [[7, 0, 0, 0, 5], [0, 6, 0, 4, 0], [0, 0, 2, 0, 0], [0, 4, 0, 6, 0], [5, 0, 0, 0, 7]], "predicted_output": "[[6, 4, 4],\n [2, 2, 2],\n [4, 6, 6]]", "expected_output": [[7, 6, 5], [4, 2, 4], [5, 6, 7]]}, "caa06a1f": {"instruction": "1. Identify the smallest rectangular region in the input grid that contains all cells not equal to the background color (the background color is the value that fills the bottom right corner portion of the grid; in this case, it is 3).\n2. Crop this rectangle so that none of the background color (3) appears in the rectangle.\n3. Rotate the cropped rectangle by 1 cell to the left along each row (i.e., perform a single left circular shift for each row).\n4. Reconstruct the output grid so that its shape matches the size of the cropped rectangle, using the rotated rows from step 3.", "test_input": [[8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 3, 3, 3, 3, 3, 3], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]], "predicted_output": "[[5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5],\n [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5],\n [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5],\n [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5],\n [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5],\n [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8],\n [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5]]", "expected_output": [[5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5], [5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8], [7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5, 7, 8, 5]]}, "cad67732": {"instruction": "1. Determine the size N of the input grid (for this grid, N=10).\n2. Create a new output grid of size (2N) x (2N) (for this example, 20x20), initializing all cells to 0.\n3. For each row i from 0 to N-1 in the input grid:\n    a. For each column j from 0 to N-1 in the input grid:\n        i. Copy the value from input[i][j] into output[i + j][j + i].\n4. The resulting output grid will contain N diagonals of the original values, each shifted further down and right, filling a diamond pattern.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 0, 0, 4, 8, 6], [0, 0, 0, 0, 0, 0, 6, 6, 4, 0], [0, 0, 0, 0, 0, 4, 8, 6, 0, 0], [0, 0, 0, 0, 6, 6, 4, 0, 0, 0], [0, 0, 0, 4, 8, 6, 0, 0, 0, 0], [0, 0, 6, 6, 4, 0, 0, 0, 0, 0], [0, 4, 8, 6, 0, 0, 0, 0, 0, 0], [6, 6, 4, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 6, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 6, 0, 4, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0],\n [0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0],\n [0, 0, 6, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0],\n [0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0],\n [6, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0],\n [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "cb227835": {"instruction": "1. For each cell in the input grid that contains an '8', draw a symmetric \"V\" pattern of '3's around it as follows:\n    a. From the position of '8', move one step up (if possible), then, for each subsequent row above, move both diagonally left and right, placing a '3' in those positions, until the grid edge is reached or the desired pattern length is complete (continue as long as possible without overlapping the edge).\n    b. On each row traversed, the '3's form mirrored arms extending out left and right from the column of the '8', stopping at the grid's boundary.\n    c. The base of the \"V\" is at the '8', and the arms extend upward and outward with each step above.\n2. Repeat step 1 for any other '8's in the grid, spacing as needed to avoid overlap.\n3. Keep all '8's unchanged. All other grid cells remain their original value unless covered by a '3' from the pattern.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]]}, "cbded52d": {"instruction": "1. For each row in the grid, check if the row contains a unique non-1, non-0 value (i.e., a value other than 1 or 0 that is present once or more in that row).\n2. For each such row, replace the value at the 5th position (index 4) with the same non-1, non-0 value found elsewhere in that row. Leave other values unchanged.\n3. Repeat this for all rows in the grid.", "test_input": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 8, 0, 1, 1, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 1, 1, 0, 6, 1], [1, 1, 0, 1, 1, 0, 1, 8]], "predicted_output": "[[1, 1, 0, 1, 8, 0, 1, 1],\n [1, 8, 0, 1, 8, 0, 1, 8],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 0, 1, 1, 0, 1, 1],\n [1, 1, 0, 1, 1, 0, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0],\n [6, 1, 0, 1, 6, 0, 6, 1],\n [1, 1, 0, 1, 8, 0, 1, 8]]", "expected_output": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 8, 0, 1, 8, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 6, 1, 0, 6, 1], [1, 1, 0, 1, 1, 0, 1, 8]]}, "cc9053aa": {"instruction": "1. For each row in the grid, check if the first nonzero element from the left is a 9. If so, replace every 8 in that row that is to the right of the first 9 (including the cell of the first 9 itself) with 9, up to and including the next 9 (if any) or until the end of the row.\n2. For each row in the grid, check if the last nonzero element from the right is a 9. If so, replace every 8 in that row that is to the left of the last 9 (including the cell of the last 9 itself) with 9, up to and including the previous 9 (if any) or until the start of the row.\n3. For each column in the grid, check if the first nonzero element from the top is a 9. If so, replace every 8 in that column that is below the first 9 (including the cell of the first 9 itself) with 9, down to and including the next 9 (if any) or until the bottom of the column.\n4. For each column in the grid, check if the last nonzero element from the bottom is a 9. If so, replace every 8 in that column that is above the last 9 (including the cell of the last 9 itself) with 9, up to and including the previous 9 (if any) or until the top of the column.\n5. Leave all non-8 and non-affected cells unchanged.", "test_input": [[0, 9, 0, 0, 0, 0, 0, 9, 0], [0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 0, 8, 7, 8, 0, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 0, 8, 7, 8, 0, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 9, 0, 0, 0, 0, 0, 9, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 8, 0, 8, 7, 8, 0, 8, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 8, 0, 8, 7, 8, 0, 8, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 8, 0, 8, 0, 8, 0, 8, 0],\n [0, 8, 8, 8, 8, 8, 8, 8, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 9, 0, 0, 0, 0, 0, 9, 0], [0, 9, 8, 8, 8, 8, 8, 9, 0], [0, 9, 0, 8, 7, 8, 0, 9, 0], [0, 9, 8, 8, 8, 8, 8, 9, 0], [0, 9, 0, 8, 7, 8, 0, 9, 0], [0, 9, 8, 8, 8, 8, 8, 9, 0], [0, 9, 0, 8, 0, 8, 0, 9, 0], [0, 9, 9, 9, 9, 9, 9, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "ccd554ac": {"instruction": "1. Take the input grid and treat it as a tile.\n2. Create a new grid by repeating the input tile both horizontally and vertically, each as many times as the number of rows in the input grid.\n3. Specifically, if the input grid has N rows and M columns, create a grid of size (N\u00d7N) rows by (M\u00d7N) columns. Each block of size N\u00d7M within the output grid is a copy of the input grid.\n4. The resulting grid will have the input pattern tiled in a square grid layout, filling the new larger grid.", "test_input": [[0, 8, 8, 0, 0], [8, 8, 8, 8, 8], [0, 8, 8, 0, 0], [8, 8, 8, 8, 8], [0, 8, 8, 0, 8]], "predicted_output": "[[0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 8, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 8, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 8, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 8, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8, 0, 8, 8, 0, 8]]}, "cce03e0d": {"instruction": "1. Create a new grid that is 9 times larger than the input grid, by tiling a 3x3 grid of blocks, each of the same size as the input grid, to form a 9x9 grid.\n2. Place a copy of the input grid in each of the nine 3x3 blocks in the following positions:\n   - Top-left block (rows 0-2, columns 0-2)\n   - Top-center block (rows 0-2, columns 3-5)\n   - Top-right block (rows 0-2, columns 6-8)\n   - Center-left block (rows 3-5, columns 0-2)\n   - Center block (rows 3-5, columns 3-5)\n   - Center-right block (rows 3-5, columns 6-8)\n   - Bottom-left block (rows 6-8, columns 0-2)\n   - Bottom-center block (rows 6-8, columns 3-5)\n   - Bottom-right block (rows 6-8, columns 6-8)\n3. For the center three blocks (center-left, center, and center-right, i.e., rows 3-5), and for the center three columns of each block (columns 3-5), replace all of their values with 0 (i.e., fill the middle row and column of 3x3 blocks entirely with 0 except for positions that overlap with the diagonal blocks).\n4. The final output grid should have the input grid placed in the three main diagonals: top-left to bottom-right, top to bottom center, and left to right center, and the rest filled with zeros.", "test_input": [[1, 2, 2], [2, 0, 1], [1, 2, 0]], "predicted_output": "[[1, 2, 2, 0, 0, 0, 0, 0, 0],\n [2, 0, 1, 0, 0, 0, 0, 0, 0],\n [1, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 1, 2, 2, 0, 0, 0],\n [0, 0, 0, 2, 0, 1, 0, 0, 0],\n [0, 0, 0, 1, 2, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 1, 2, 2],\n [0, 0, 0, 0, 0, 0, 2, 0, 1],\n [0, 0, 0, 0, 0, 0, 1, 2, 0]]", "expected_output": [[0, 0, 0, 1, 2, 2, 1, 2, 2], [0, 0, 0, 2, 0, 1, 2, 0, 1], [0, 0, 0, 1, 2, 0, 1, 2, 0], [1, 2, 2, 0, 0, 0, 0, 0, 0], [2, 0, 1, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 2, 0, 0, 0], [0, 0, 0, 2, 0, 1, 0, 0, 0], [0, 0, 0, 1, 2, 0, 0, 0, 0]]}, "cd3c21df": {"instruction": "1. Scan the input grid to identify every contiguous non-background (non-zero) rectangular block of cells.\n2. From those blocks, find the one that contains only the minimum non-background values and occupies the minimal rectangle, i.e., a distinct non-background rectangular area smaller than the others (typically surrounded by larger or longer clusters).\n3. Select this smallest non-background block that is not part of a longer \"bar\" or larger square elsewhere; it typically stands out as a uniquely compact group (e.g., a 2x3 or 2x2 rectangle).\n4. Extract only the region of this smallest block, cropping out all rows and columns outside this rectangle, preserving the original colors and arrangement within this minimal bounding rectangle.\n5. Output the cropped block as the final grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 8, 4, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[4, 8],\n [8, 8],\n [8, 4]]", "expected_output": [[4, 8], [8, 8], [8, 4]]}, "cdecee7f": {"instruction": "1. Identify all nonzero values in the input grid and record their positions as (row, column, value).\n2. Separate the nonzero values into three groups based on the row index:\n    - Group 1: Top three nonzero values with the smallest row indices.\n    - Group 2: Middle three nonzero values with the next three smallest row indices.\n    - Group 3: Bottom three nonzero values with the greatest row indices.\n3. Within each group, sort the values in increasing order of their column index (i.e., left to right).\n4. Create a new 3x3 output grid. Place the values of:\n    - Group 1 in the top row (row 0),\n    - Group 2 in the middle row (row 1),\n    - Group 3 in the bottom row (row 2),\n   preserving the left-to-right order from each group.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[5, 9, 1],\n [2, 6, 3],\n [5, 4, 9]]", "expected_output": [[5, 2, 9], [4, 5, 3], [9, 6, 1]]}, "ce039d91": {"instruction": "1. For every cell in the grid, if the value is 5, check if it is part of a horizontal or vertical contiguous segment of 5s (length at least 2).\n2. For each segment of 5s:\n    a. If a segment is a horizontal or vertical line with length >= 2, replace every 5 in that segment with 1, except at the endpoints of that segment, which remain 5.\n    b. If a single cell of value 5 is isolated (not part of a length-2-or-more segment), leave it unchanged.\n3. All cells that are neither 5 nor part of such a segment remain unchanged.", "test_input": [[0, 5, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 5, 0, 5, 5, 5, 5, 0, 5, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 0, 0, 0]], "predicted_output": "[[0, 5, 0, 0, 0, 0, 0, 0, 5, 0],\n [0, 0, 0, 0, 5, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n [0, 5, 0, 0, 0, 0, 0, 5, 0, 0],\n [0, 0, 0, 0, 5, 5, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n [0, 5, 0, 5, 1, 1, 5, 0, 5, 0],\n [0, 0, 0, 0, 5, 1, 0, 0, 0, 0],\n [0, 0, 0, 5, 1, 1, 1, 5, 0, 0],\n [0, 0, 5, 1, 1, 1, 5, 0, 0, 0]]", "expected_output": [[0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 5, 0, 0], [0, 0, 5, 1, 1, 1, 1, 0, 0, 0]]}, "ce22a75a": {"instruction": "1. Identify all the positions of the number 5 in the input grid.\n2. For each 5 found, create a 3x3 block of 1s such that the 3x3 block is aligned so that the 5 is at the center of the block. This means the 1s occupy the area from one row above to one below and one column left to one right of the 5, as long as those positions are within the grid bounds.\n3. If multiple 3x3 blocks overlap, allow the overlapping positions to remain as 1.\n4. Set all other positions to 0.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 1, 1, 1],\n [0, 1, 1, 0, 0, 1, 1, 1, 1],\n [0, 1, 1, 0, 0, 1, 1, 1, 1],\n [0, 1, 1, 0, 0, 1, 1, 1, 1],\n [1, 1, 1, 0, 0, 1, 1, 1, 1],\n [1, 1, 1, 0, 0, 1, 1, 1, 1],\n [1, 1, 1, 0, 0, 1, 1, 1, 1],\n [1, 1, 1, 0, 0, 1, 1, 1, 0],\n [1, 1, 1, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0]]}, "ce4f8723": {"instruction": "1. Divide the input grid into two sections: the upper section consists of the rows above the separator row (where all entries are 4), and the lower section consists of the rows below the separator row.\n2. Discard the separator row and all rows below it; only use the upper section (the first set of rows above the separator of 4s).\n3. For each cell in the upper section, do the following transformation:\n    a. If the cell value is 1, change it to 3.\n    b. If the cell value is 0, leave it as 0.\n4. The resulting transformed upper section is the output grid.", "test_input": [[1, 0, 1, 0], [1, 0, 1, 0], [0, 1, 0, 0], [1, 0, 1, 0], [4, 4, 4, 4], [2, 2, 0, 0], [0, 0, 2, 0], [0, 2, 0, 2], [2, 2, 2, 0]], "predicted_output": "[[3, 0, 3, 0],\n [3, 0, 3, 0],\n [0, 3, 0, 0],\n [3, 0, 3, 0]]", "expected_output": [[3, 3, 3, 0], [3, 0, 3, 0], [0, 3, 0, 3], [3, 3, 3, 0]]}, "ce602527": {"instruction": "1. Identify the two distinct regions with patterns different from the background color. These regions are separated spatially in the grid (one in the top half, one in the bottom half).\n2. For the upper patterned region: Locate the non-background color (6) blocks forming a cross pattern near the left-center of the grid. Crop out the smallest rectangle that contains all these 6-colored cells and their immediate context of 3-colored background in a 5x5 square.\n3. For the lower patterned region: Locate the non-background color (8) blocks forming a solid rectangle near the lower center of the grid. Crop out the smallest rectangle that contains all these 8-colored cells and their immediate context of 3-colored background in a 5x5 square.\n4. Collect the two cropped 5x5 regions (top containing the \"6\" cross centered on 3 background, bottom containing the \"8\" block surrounded by 3 background).\n5. Stack the two 5x5 cropped grids vertically, placing the \"6\" cross region above the \"8\" block region, to form a new 10x5 output grid.", "test_input": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3]], "predicted_output": "[[3, 3, 6, 3, 3],\n [3, 6, 6, 6, 3],\n [6, 6, 6, 6, 6],\n [3, 6, 6, 6, 3],\n [3, 3, 6, 3, 3],\n [3, 3, 8, 3, 3],\n [3, 8, 8, 8, 3],\n [8, 8, 8, 8, 8],\n [3, 8, 8, 8, 3],\n [3, 3, 8, 3, 3]]", "expected_output": [[3, 6, 3], [6, 6, 6], [3, 6, 3], [6, 6, 6]]}, "ce8d95cc": {"instruction": "1. Identify the repeating vertical stripes or columns of interest in the input grid. These are defined by columns which have nonzero numbers forming vertical lines at regular intervals (for example, a vertical stripe of the same number, surrounded mostly by zeros, and repeated elsewhere horizontally).\n2. Determine the groupings of these stripes:\n   - Each grouping consists of 3 adjacent columns centered on each vertical stripe, and the space between the centers forms the width of the region to extract.\n   - In case of the sample grids, group each set by their pattern: e.g., a center column with its left/right adjacent zero columns (width=3), separated by sets of zeros.\n3. Starting from the left, identify all such groupings until the end of the row (there may be several in each row).\n4. For each grouping, extract all columns for that group, preserving their order, into a new subgrid.\n5. In the output, each subgrid group will be reduced vertically by removing all-empty (all-zeros) rows at the top and the bottom, until a uniquely-patterned block remains for each group.\n6. Stack the resulting blocks horizontally to rebuild the output grid corresponding to each group, with their respective columns preserved, but only one row per unique pattern present in the vertical (remove vertical repetition).\n7. Preserve the original vertical order of the unique rows from the first appearance downward for each group.\n8. Stack all produced subgrids vertically in their original left-to-right sequence to form the final grid.", "test_input": [[0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [6, 6, 6, 6, 6, 2, 6, 7, 6, 6, 4, 6, 6], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [1, 1, 1, 1, 1, 2, 1, 7, 1, 1, 4, 1, 1], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 4, 8, 8], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0], [0, 0, 3, 0, 0, 2, 0, 7, 0, 0, 4, 0, 0]], "predicted_output": "[[0, 0, 3],\n [6, 6, 6],\n [1, 1, 1],\n [8, 8, 8],\n [0, 0, 2],\n [6, 6, 2],\n [1, 1, 2],\n [8, 8, 8],\n [0, 7, 0],\n [6, 7, 6],\n [1, 7, 1],\n [8, 7, 8],\n [0, 0, 4],\n [6, 4, 6],\n [1, 4, 1],\n [8, 4, 8]]", "expected_output": [[0, 3, 0, 2, 0, 7, 0, 4, 0], [6, 6, 6, 2, 6, 7, 6, 4, 6], [0, 3, 0, 2, 0, 7, 0, 4, 0], [1, 1, 1, 2, 1, 7, 1, 4, 1], [0, 3, 0, 2, 0, 7, 0, 4, 0], [8, 8, 8, 8, 8, 7, 8, 4, 8], [0, 3, 0, 2, 0, 7, 0, 4, 0]]}, "ce9e57f2": {"instruction": "1. Starting from the bottom row and moving upward, find the first row (let's call it the \"highlight row\") in which there are more than one cell in the same column (in the vertical direction) that have the value 2, forming a consecutive vertical \"bar\" of 2s starting from the leftmost 2-column. This row is the one where non-interrupted columns of 2s are at least two cells tall.\n2. For every row below (including) this highlight row, and for each column, do the following:\n    a. If the cell in the current row and column contains a 2 and the cell directly above it also contains a 2, change the current cell from 2 to 8.\n    b. Else, leave it unchanged.\n3. All other cells (including those above the highlight row or separated from a consecutive bar of 2s) remain unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 2, 0, 2, 0, 0, 0, 0, 0],\n [0, 2, 0, 2, 0, 0, 0, 0, 0],\n [0, 2, 0, 2, 0, 0, 0, 0, 0],\n [0, 2, 0, 2, 0, 0, 0, 0, 0],\n [0, 8, 0, 8, 0, 0, 0, 0, 0],\n [0, 8, 0, 8, 0, 0, 0, 2, 0],\n [0, 8, 0, 8, 0, 0, 0, 8, 0],\n [0, 8, 0, 8, 0, 2, 0, 8, 0],\n [0, 8, 0, 8, 0, 8, 0, 8, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 8, 0, 2, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 2, 0, 8, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0]]}, "cf133acc": {"instruction": "1. Identify each horizontal nonzero segment (a group of the same nonzero value separated by zeroes) in the input grid.\n2. For each such segment, shift it vertically so that its leftmost nonzero cell is aligned to the diagonal cell at the same x-coordinate as the start of the segment (column index becomes row index). Place the entire segment horizontally from that point, and fill the appropriate number of cells in the row, starting at that column.\n3. For each column where a shifted row ends before the grid ends, continue filling directly below with single cells of the same value, extending vertically down.\n4. Repeat for all present segments, ensuring no overlap: if two segments would write to the same cell, the uppermost (originally higher in the grid) has priority.\n5. All other cells (not part of a segment\u2019s new \u201cL\u201d or vertical fill) are set to zero.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 5, 5, 0, 5, 5, 5, 5, 5, 5],\n [0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 5, 5, 5, 5, 5],\n [0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 5, 5, 5, 5, 5],\n [3, 3, 3, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 9, 9, 0, 9, 9, 9, 9, 9, 9],\n [0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 9, 9, 9, 9, 9],\n [0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 9, 9, 9, 9, 9],\n [0, 0, 0, 0, 0, 0, 9, 0, 0, 9, 9, 9, 9, 9, 9],\n [4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 3, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0]]}, "cf5fd0ad": {"instruction": "1. For each of the three rows in the input grid, make four copies of that row and stack them vertically, so the result is a 12-row intermediate grid.\n2. For each group of three consecutive rows in the intermediate grid, transform the columns as follows:\n    - For each column in the input (three columns), expand it to four columns in the output. Use these rules for each group of three columns (i.e., columns 0-2 \u2192 columns 0-3, columns 3-5 \u2192 4-7, etc):\n        - In each group of three columns from the input:\n            - Copy the three columns in the same sequence to the four new output columns, but insert an extra column before the first by shifting the sequence to repeat the last column of the group at the start.\n            - In detail, for input values [A, B, C], output columns will be: [C, A, B, C]\n3. Fill in each 3\u00d73 block in the output using the above mapping, so that the 12\u00d712 output is divided into 3\u00d73 blocks, where each block applies the above expansion for both rows and columns.", "test_input": [[8, 8, 8], [8, 8, 2], [8, 6, 4]], "predicted_output": "[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 2],\n [8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 2],\n [8, 8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 2],\n [8, 8, 8, 8, 6, 8, 8, 6, 4, 6, 8, 4],\n [8, 8, 8, 8, 6, 8, 8, 6, 4, 6, 8, 4],\n [8, 8, 8, 8, 6, 8, 8, 6, 4, 6, 8, 4],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[4, 6, 8, 4, 6, 8, 8, 8, 8, 8, 8, 8], [2, 8, 8, 2, 8, 8, 6, 8, 8, 6, 8, 8], [8, 8, 8, 8, 8, 8, 4, 2, 8, 4, 2, 8], [4, 6, 8, 4, 6, 8, 8, 8, 8, 8, 8, 8], [2, 8, 8, 2, 8, 8, 6, 8, 8, 6, 8, 8], [8, 8, 8, 8, 8, 8, 4, 2, 8, 4, 2, 8], [8, 2, 4, 8, 2, 4, 8, 8, 8, 8, 8, 8], [8, 8, 6, 8, 8, 6, 8, 8, 2, 8, 8, 2], [8, 8, 8, 8, 8, 8, 8, 6, 4, 8, 6, 4], [8, 2, 4, 8, 2, 4, 8, 8, 8, 8, 8, 8], [8, 8, 6, 8, 8, 6, 8, 8, 2, 8, 8, 2], [8, 8, 8, 8, 8, 8, 8, 6, 4, 8, 6, 4]]}, "cf98881b": {"instruction": "1. Partition the input grid into four vertical sections, each of width 4 columns, starting from the left (i.e., columns 0\u20133, 4\u20137, 8\u201311, and 12\u201313). \n2. For each of the four vertical sections, select the main diagonal elements, that is, the elements at positions (row i, column i) in each 4-column section.\n3. For each 4x1 set of diagonal elements extracted from each section, arrange them to form a column of the output grid. Specifically, assemble each output column using the diagonal elements in order from top row (row 0, col 0) to bottom row (row 3, col 3) in each section.\n4. Concatenate the four columns formed from the four sections to generate a 4x4 output grid, where each column comes from the corresponding section's diagonal.", "test_input": [[0, 0, 4, 0, 2, 9, 0, 9, 0, 2, 1, 1, 0, 0], [4, 4, 0, 4, 2, 9, 9, 9, 0, 2, 1, 1, 1, 0], [0, 0, 0, 0, 2, 0, 9, 9, 9, 2, 1, 1, 0, 1], [0, 4, 4, 0, 2, 9, 0, 9, 9, 2, 1, 0, 0, 0]], "predicted_output": "[[0, 2, 1, 0],\n [4, 9, 1, 0],\n [0, 9, 1, 1],\n [0, 9, 0, 0]]", "expected_output": [[9, 1, 4, 0], [4, 4, 9, 4], [1, 9, 9, 9], [9, 4, 4, 9]]}, "cfb2ce5a": {"instruction": "1. Locate all non-background (nonzero) connected shapes or grouped regions within the grid.\n2. For each detected shape or region, horizontally extend it to the right so that its rightmost boundary now reaches the next nonzero region's leftmost column (or to the furthest right possible within its containing block) without interfering with or overlapping other shapes. Fill with the block's color or the existing pattern along that row or block.\n3. Repeat the extension vertically downward as well: for each detected shape or region, extend it downward to the next distinct horizontal band or shape (or the grid boundary), filling with the appropriate color or pattern as seen in its original row.\n4. If a region is at the edge and cannot be extended further without overlapping or going outside the main grouped area, stop extending at that edge.\n5. For any isolated numeric or color elements that appear beneath or to the side of the main shape clusters, expand and \"clone\" the patterns present above or to the side into the empty neighboring cells, matching the replication seen in the examples.\n6. Any new rows or columns formed during expansion should carry over the extended patterns and colors from the original shapes, as observed in the sample grids.\n7. Preserve the zero (background) border of the grid; only fill within the area defined by the nonzero shapes' extended boundaries.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 1, 1, 8, 0, 0, 0, 0], [0, 4, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 4, 0, 0, 0, 0, 0], [0, 1, 1, 4, 4, 5, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 1, 1, 8, 8, 8, 8, 0],\n [0, 4, 1, 1, 1, 8, 8, 8, 8, 0],\n [0, 1, 1, 1, 4, 5, 5, 5, 5, 0],\n [0, 1, 1, 4, 4, 5, 5, 5, 5, 0],\n [0, 1, 1, 4, 4, 5, 5, 5, 5, 0],\n [0, 7, 7, 7, 7, 5, 5, 5, 5, 0],\n [0, 7, 7, 7, 7, 5, 5, 5, 5, 0],\n [0, 7, 7, 7, 7, 5, 5, 5, 5, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 1, 1, 8, 8, 5, 5, 0], [0, 4, 1, 1, 1, 8, 8, 8, 5, 0], [0, 1, 1, 1, 4, 5, 8, 8, 8, 0], [0, 1, 1, 4, 4, 5, 5, 8, 8, 0], [0, 7, 7, 6, 6, 0, 0, 3, 3, 0], [0, 7, 7, 7, 6, 0, 3, 3, 3, 0], [0, 6, 7, 7, 7, 3, 3, 3, 0, 0], [0, 6, 6, 7, 7, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}}