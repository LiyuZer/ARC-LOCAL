{"516b51b7": {"instruction": "1. For each distinct region in the grid made up of contiguous 1s (connected horizontally or vertically, and separated from other 1-regions by zeros), identify its boundaries (the minimal rectangle that contains all the 1s of that region).\n2. For each such rectangular region, replace all 1s on the outermost layer (the boundary layer) with the value 1.\n3. Working inwards, replace all 1s that are exactly one step inside the boundary (i.e., all 1s surrounded by other 1s) with the value 2, forming a second layer.\n4. Continue this pattern, increasing the fill value by 1 for each concentric inward step, until you reach the innermost region. If a region forms a \"core\" that is surrounded by a full layer on all sides, increment the value further for that core (e.g., core=3 or core=4, etc.), as appropriate for the number of layers.\n5. All grid cells that are not part of any filled region (originally 0) remain as 0s in the output.", "test_input": [[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]], "predicted_output": "[[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],\n [0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0],\n [0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0],\n [0, 0, 1, 2, 3, 4, 4, 4, 4, 4, 3, 2, 1, 0, 0, 0, 0],\n [0, 0, 1, 2, 3, 4, 5, 5, 5, 4, 3, 2, 1, 0, 0, 0, 0],\n [0, 0, 1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0],\n [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0],\n [0, 1, 2, 2, 2, 1, 0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0],\n [0, 1, 2, 3, 2, 1, 0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0], [0, 0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0, 0, 0, 0], [0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0], [0, 1, 2, 2, 2, 1, 0, 0, 0, 1, 2, 3, 2, 3, 2, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 2, 3, 2, 3, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]]}, "5207a7b5": {"instruction": "1. Locate the vertical line of contiguous '5' cells in the input grid. Note its starting column index (let's call this c) and the starting and ending row indices (let's call them r_start and r_end).\n2. For all rows from 0 to (r_end - r_start), fill the leftmost (c) columns in each of these rows with the value '8'. For each subsequent pair of rows below, decrease the number of columns filled with '8' by one every two rows (i.e., after every two rows, fill one less column with '8').\n3. Copy the vertical line of '5's into the output grid at its original position.\n4. To the immediate right of the vertical '5's, in each row from r_start to r_end, fill the next column(s) to the right of the '5' with the value '6'. For the top two rows of the '5' line, fill two cells with '6' to the right of each '5', for the next two rows fill one cell, then for the next pairs, none.\n5. Ensure that outside the filled regions, all remaining cells are set to 0.", "test_input": [[0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[8, 8, 8, 5, 6, 6, 0, 0, 0],\n [8, 8, 8, 5, 6, 6, 0, 0, 0],\n [8, 8, 5, 6, 0, 0, 0, 0, 0],\n [8, 8, 5, 6, 0, 0, 0, 0, 0],\n [8, 5, 0, 0, 0, 0, 0, 0, 0],\n [8, 5, 0, 0, 0, 0, 0, 0, 0],\n [5, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[8, 8, 8, 5, 6, 6, 6, 0, 0], [8, 8, 8, 5, 6, 6, 0, 0, 0], [8, 8, 8, 5, 6, 6, 0, 0, 0], [8, 8, 8, 5, 6, 0, 0, 0, 0], [8, 8, 8, 5, 6, 0, 0, 0, 0], [8, 8, 8, 5, 0, 0, 0, 0, 0], [8, 8, 8, 5, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "522fdd07": {"instruction": "1. Identify each non-background colored block in the grid. The background color is 7. Each block consists of adjacent (including diagonally unconnected) cells of the same color (excluding 7).\n2. For each identified colored block, do the following:\n    a. Remove the block from its original position (replace its cells with the background color 7).\n    b. Place the entire block in a fixed new region of the grid:\n        - If the block's color is the leftmost non-background color at the top of the grid, reposition it so its top-left cell is at row 1, column 1.\n        - If the block's color is the topmost non-background color group on the right edge, reposition it so its top-left cell aligns with row 1, and the block appears flush against the right edge but shifted one column in (i.e., starting in the second rightmost column).\n        - If the block's color is in the middle left (such as a vertical arrangement starting left and low), reposition it so its top-left cell is at row 5, column 2.\n        - If there are three horizontally consecutive cells of the same non-background color spanning a row near the bottom-right, reposition this horizontal block so it is aligned vertically in column 13 with its topmost cell at row 13.\n    c. When repositioned, fill the region of the block with its color, leaving no gaps, but preserve the block's original shape.\n3. All other positions in the grid are filled with the background color 7.", "test_input": [[3, 3, 3, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9], [3, 3, 3, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9], [3, 3, 3, 7, 1, 1, 1, 7, 7, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 1, 1, 1, 7, 7, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 1, 1, 1, 7, 7, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4, 4, 4, 4]], "predicted_output": "[[3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7],\n [3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7],\n [3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7],\n [7, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 1, 1, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7], [7, 7, 7, 7, 7, 1, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 4, 4, 4, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 4, 4, 4, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 4, 4, 4, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7]]}, "52364a65": {"instruction": "1. For each distinct non-background color region (where the background is 8), if the region is not touching the border of the grid, perform the following steps:\n    a. For regions in the top-left or bottom-right quadrants, shift the entire region one unit towards the center (right for left regions, left for right regions, down for top regions, up for bottom regions), effectively overwriting background cells with the region's color and filling the vacated cells with the background (8).\n    b. For regions at the center or not touching a border, shift them inwards (e.g., for the \"4\"-region, move the central \"4\" block to the right, collapsing left-side \"4\"s and replacing with \"8\").\n2. For corner blocks present along the outer edges (for example, the rightmost vertical \"6\"-block), trim them such that only the innermost portion adjacent to the rest of the non-background structure remains (remove \"loose\" outer blocks).\n3. In the lower rows, for horizontal color blocks that extend to the border, shrink them inwards (cut the leftmost colored blocks if at left, cut the rightmost if at right), while preserving the contiguous nature of the block.\n4. Set all vacated cells (any cells that have been cleared of their previous color) to the background color 8.", "test_input": [[8, 8, 8, 8, 8, 8, 6, 6], [8, 8, 8, 8, 8, 8, 6, 6], [4, 8, 8, 4, 8, 8, 6, 6], [4, 4, 4, 4, 8, 8, 8, 8], [4, 8, 8, 4, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 8, 5, 5, 5, 5], [2, 2, 2, 8, 5, 5, 5, 5]], "predicted_output": "[[8, 8, 8, 8, 8, 6, 6, 8],\n [8, 8, 8, 8, 8, 6, 6, 8],\n [8, 8, 8, 8, 8, 6, 6, 8],\n [8, 4, 4, 8, 8, 8, 8, 8],\n [8, 8, 4, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8],\n [8, 2, 8, 5, 5, 5, 8, 8],\n [8, 2, 8, 5, 5, 5, 8, 8]]", "expected_output": [[8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 4, 8, 8, 8, 8], [8, 8, 4, 4, 8, 8, 8, 8], [8, 8, 8, 4, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 2, 8, 8, 8, 5, 5], [8, 8, 2, 8, 8, 8, 5, 5]]}, "5289ad53": {"instruction": "1. Scan the input grid for all contiguous horizontal line segments (length \u22652) composed of the same non-background color. (The background color is the most common color, e.g., 0, 1, 5, or 8 in the tested grids.)\n2. For each distinct non-background color, count the number of horizontal segments present in the grid.\n3. Construct the output grid as follows:\n    - Each row of the output grid corresponds to one color found (ordered by the color number, smallest first).\n    - Each row should contain one integer per segment size found in that color, in descending order of segment size. If there are multiple segments for the same color, add all their sizes, largest to smallest, as consecutive entries in the row.\n    - If a color has fewer than 3 segments, fill extra columns with 0 so each row has 3 columns.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[4, 4, 2],\n [6, 2, 2]]", "expected_output": [[3, 3, 3], [2, 2, 2]]}, "52df9849": {"instruction": "1. For each connected block of non-background color (where the background color is 7), examine the colors within the rectangle (or bounding box) surrounding each block.\n2. For any block where a \"frame\" or \"outline\" of a non-background color fully surrounds an interior area of another color (i.e., a solid border or perimeter of one color enclosing another color), remove the interior area and replace it with the color of the enclosing border (i.e., \"hollow out\" the inside and fill with the frame\u2019s color).\n3. Repeat this for all such blocks: Specifically, for every group of rows and columns bordered by the same color, convert all inner cells fully surrounded horizontally and vertically to the border color.\n4. Do not alter any blocks or regions that are not fully enclosed by a border.\n5. Leave all other grid values unmodified.", "test_input": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 9, 5, 5, 9, 9, 8, 8, 9, 9, 6, 6, 6, 6, 9, 7], [7, 9, 5, 5, 9, 9, 8, 8, 9, 9, 6, 6, 6, 6, 9, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1], [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1], [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 9, 9, 9, 9, 9, 8, 8, 9, 9, 6, 6, 6, 6, 9, 7],\n [7, 9, 9, 9, 9, 9, 8, 8, 9, 9, 6, 6, 6, 6, 9, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1],\n [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1],\n [1, 1, 5, 5, 1, 1, 8, 8, 1, 1, 6, 6, 6, 6, 1, 1],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7], [7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 5, 5, 7, 7, 8, 8, 7, 7, 6, 6, 6, 6, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]}, "52fd389e": {"instruction": "1. For each isolated rectangular block of nonzero (colored) cells surrounded by zeros, identify its boundaries (top, bottom, left, right).\n2. For each such block, add a single-cell-thick border completely around it (including corners) with a color determined uniquely per grid:\n   - If the block's main fill color is 4, use the next unique color appearing within the enclosed block for the border (if not present, use a new color not already present if following the pattern in the examples). If multiple colors are already inside, use the one that is not 4 and not used as a border elsewhere in the grid for that region (border color is always unique between blocks within a grid).\n   - If the block contains special \"interior\" colors (such as 1, 3, or 6 in the examples), treat these as decorations\u2014do not overwrite them with the border.\n3. Make sure to not overwrite any interior nonzero (colored) cells with the border; the border only sits in the zero cells directly adjacent to the outermost edge of the colored region.\n4. For regions where there are composite/adjacent blocks separated by zeros, treat each as independent for bordering.\n5. Leave all other cells (outside any bordered region) unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 6, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 6, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 6, 4, 6, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 4, 4, 5, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 4, 4, 4, 1, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 3, 4, 5, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 4, 4, 4, 4, 4, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 4, 4, 5, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 6, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 4, 4, 6, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 6, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 4, 6, 4, 6, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 4, 4, 4, 4, 4, 4, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 1, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 1, 4, 4, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 1, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 3, 4, 4, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 4, 4, 3, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 4, 4, 4, 4, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 4, 4, 4, 6, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 4, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 6, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 6, 4, 6, 4, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "538b439f": {"instruction": "1. For each row in the grid, identify the unique column index that contains the value 3. This column is the \"pivot\" for that row.\n2. For each such row, examine the 3 consecutive cells immediately to the left of the pivot (columns: pivot-3, pivot-2, pivot-1) and the 3 consecutive cells immediately to the right of the pivot (columns: pivot+1, pivot+2, pivot+3). These six cells constitute the \"highlight\" region for that row.\n3. For all cells in the highlight region (as defined above), if the original value is 4, change it to 2. If the value is any other number, keep it as is.\n4. Keep all other cells (including the pivot itself) unchanged.", "test_input": [[4, 4, 4, 4, 9, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4], [4, 4, 9, 4, 4, 2, 2, 9, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4], [4, 4, 4, 4, 4, 2, 2, 4, 4, 3, 4, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 9, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 9, 9, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4], [4, 4, 2, 2, 2, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4], [4, 9, 2, 2, 2, 4, 4, 4, 4, 3, 4, 4, 9, 4, 9, 4, 4, 4, 4, 4, 9, 4, 4], [4, 4, 2, 2, 2, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 2, 2, 2, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 9, 2, 2, 2, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 9, 4, 4, 3, 4, 4, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [9, 4, 4, 2, 2, 2, 4, 9, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 9, 4, 4], [4, 4, 4, 2, 2, 2, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 2, 2, 2, 4, 4, 4, 3, 4, 9, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "predicted_output": "[[4, 4, 4, 4, 9, 4, 4, 2, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4],\n [4, 4, 9, 4, 4, 2, 2, 9, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 2, 2, 4, 2, 3, 2, 2, 4, 4, 4, 4, 9, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 9, 4, 4, 2, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 9, 9, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4],\n [4, 4, 2, 2, 2, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4],\n [4, 9, 2, 2, 2, 4, 4, 4, 2, 3, 2, 2, 9, 4, 9, 4, 4, 4, 4, 4, 9, 4, 4],\n [4, 4, 2, 2, 2, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 2, 2, 2, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 9, 2, 2, 2, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 9, 4, 2, 3, 2, 2, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [9, 4, 4, 2, 2, 2, 4, 9, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 9, 4, 9, 4, 4],\n [4, 4, 4, 2, 2, 2, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [4, 4, 4, 2, 2, 2, 4, 4, 2, 3, 2, 9, 4, 4, 4, 4, 4, 9, 4, 4, 4, 4, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 2, 3, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]", "expected_output": [[4, 4, 4, 4, 9, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4], [4, 4, 9, 4, 4, 2, 2, 3, 3, 3, 3, 3, 2, 2, 4, 4, 4, 4, 9, 4, 4, 4, 4], [4, 4, 4, 4, 4, 2, 2, 3, 3, 3, 3, 3, 2, 2, 4, 4, 9, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 9, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 9, 9, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 9, 4, 4], [4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 9, 4], [4, 9, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 9, 4, 4], [4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4], [4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4], [4, 9, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 9, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 9, 4, 4, 3, 4, 4, 9, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [9, 4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 9, 4, 9, 4, 4], [4, 4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 4, 9, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]}, "539a4f51": {"instruction": "1. Take the input grid and create a copy of it.\n2. Place 4 copies of the input grid horizontally, with each new copy placed to the right of the previous one, forming a row of 4 grids in total.\n3. Take the first row of the input grid, and repeat this row enough times to form a square block matching the original grid\u2019s height. Do this for each row in the grid to create a solid block of each row. Stack these row blocks vertically, replacing the corresponding 'blocks' in the lower half of the output grid:\n   - For each set of output rows below the stacked copies, fill each block with a repeated value taken from the corresponding input row.\n   - For row n (where n ranges from 0 to the input grid size minus 1), fill the block of rows [n * input_size + input_size, (n+1) * input_size + input_size) with the value from the input grid row n.\n4. Assemble the final output grid by stacking the four horizontally-concatenated grids from step 2 on top, and the solid block region from step 3 below, forming a square output grid whose size is input_size * 2 in both width and height.", "test_input": [[7, 7, 3, 2, 2], [7, 7, 3, 2, 2], [3, 3, 3, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]], "predicted_output": "[[7, 7, 3, 2, 2, 7, 7, 3, 2, 2, 7, 7, 3, 2, 2, 7, 7, 3, 2, 2],\n [7, 7, 3, 2, 2, 7, 7, 3, 2, 2, 7, 7, 3, 2, 2, 7, 7, 3, 2, 2],\n [3, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 3, 2, 2, 3, 3, 3, 2, 2],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]", "expected_output": [[7, 7, 3, 2, 2, 7, 7, 3, 2, 2], [7, 7, 3, 2, 2, 7, 7, 3, 2, 2], [3, 3, 3, 2, 2, 7, 7, 3, 2, 2], [2, 2, 2, 2, 2, 7, 7, 3, 2, 2], [2, 2, 2, 2, 2, 7, 7, 3, 2, 2], [7, 7, 7, 7, 7, 7, 7, 3, 2, 2], [7, 7, 7, 7, 7, 7, 7, 3, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}, "53b68214": {"instruction": "1. Identify the smallest rectangle that contains all nonzero cells in the input grid. Note its height and width.\n2. Copy this rectangle and repeat it vertically downwards, stacking copies beneath the original so that the total grid height matches the output grid, maintaining the alignment.\n3. Fill any remaining rows (if the repeated copies do not exactly fill the output grid) with empty (zero) rows as needed.", "test_input": [[0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 8, 8, 8],\n [0, 8, 0, 8],\n [0, 8, 8, 8],\n [0, 8, 0, 8],\n [0, 8, 8, 8],\n [0, 8, 0, 8],\n [0, 8, 8, 8],\n [0, 8, 0, 8],\n [0, 8, 8, 8],\n [0, 8, 0, 8]]", "expected_output": [[0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0]]}, "543a7ed5": {"instruction": "1. Identify all distinct rectangular regions in the input grid composed of the number 6. Each such region is bounded by 8s or the edges of the grid.\n2. For each identified 6-region:\n    a. Draw a border of 3s around the region. The border should be one cell thick and placed on the outermost boundary of the region. If the region is adjacent to 8s or the grid edge, overwrite the 8s with 3s at the border positions; otherwise, do not overwrite existing 6s.\n    b. Retain the internal structure of 6s inside the border except for the following modification.\n3. If there are any empty internal \u201choles\u201d or \u201ccenters\u201d within the 6-region (i.e., regions of 8s fully surrounded by 6s), fill those with the color 4.\n4. Ensure that overlapping or touching regions are handled such that the border 3s separate distinct regions and never overwrite existing 6s.\n5. All background (non-processed) cells should remain as 8.", "test_input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 8, 8, 8], [8, 8, 6, 6, 6, 6, 8, 8, 8, 6, 6, 6, 8, 8, 8], [8, 8, 6, 8, 8, 6, 8, 8, 8, 6, 8, 6, 8, 8, 8], [8, 8, 6, 8, 8, 6, 8, 8, 8, 6, 8, 6, 8, 8, 8], [8, 8, 6, 6, 6, 6, 8, 8, 8, 6, 8, 6, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8], [8, 8, 8, 8, 6, 6, 8, 8, 6, 6, 6, 8, 8, 8, 8], [8, 8, 8, 8, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "predicted_output": "[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 8, 8, 8],\n [8, 8, 3, 3, 3, 3, 8, 8, 8, 3, 3, 3, 8, 8, 8],\n [8, 8, 3, 6, 6, 3, 8, 8, 8, 3, 6, 3, 8, 8, 8],\n [8, 8, 3, 6, 6, 3, 8, 8, 8, 3, 6, 3, 8, 8, 8],\n [8, 8, 3, 3, 3, 3, 8, 8, 8, 3, 6, 3, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8],\n [8, 8, 8, 3, 6, 6, 3, 3, 3, 6, 3, 8, 8, 8, 8],\n [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 8, 8], [8, 3, 3, 3, 3, 3, 3, 8, 3, 6, 6, 6, 3, 8, 8], [8, 3, 6, 6, 6, 6, 3, 8, 3, 6, 6, 6, 3, 8, 8], [8, 3, 6, 4, 4, 6, 3, 8, 3, 6, 4, 6, 3, 8, 8], [8, 3, 6, 4, 4, 6, 3, 8, 3, 6, 4, 6, 3, 8, 8], [8, 3, 6, 6, 6, 6, 3, 8, 3, 6, 4, 6, 3, 8, 8], [8, 3, 3, 3, 3, 3, 3, 8, 3, 6, 6, 6, 3, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8], [8, 8, 8, 3, 6, 6, 6, 6, 6, 6, 6, 3, 8, 8, 8], [8, 8, 8, 3, 6, 6, 4, 4, 6, 6, 6, 3, 8, 8, 8], [8, 8, 8, 3, 6, 6, 6, 6, 6, 6, 6, 3, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8]]}, "54d82841": {"instruction": "1. Identify all distinct nonzero colored shapes (blocks of the same color) in the grid.\n2. For each distinct colored shape, locate its bounding box (smallest rectangle containing all nonzero values of that color).\n3. For each bounding box, find the bottom row that is immediately below the bounding box and still within the grid.\n4. In that bottom row, find the horizontal center of the colored shape (if the width is odd, the center is the middle cell; if even, center on the middle column). Place the value 4 in that center cell of the row immediately below the bounding box.\n5. If there are multiple shapes, repeat steps 2\u20134 for each shape.\n6. All other grid cells remain unchanged from the input.", "test_input": [[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 5, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0],\n [0, 5, 0, 5, 0, 8, 8, 8, 0, 0, 0],\n [0, 0, 0, 0, 0, 8, 0, 8, 3, 3, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3],\n [0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0]]", "expected_output": [[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 5, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0, 4, 0]]}, "54d9e175": {"instruction": "1. Identify horizontal zones separated by vertical columns of 5's. In each such zone, focus only on rows that do **not** consist entirely of 5's (i.e., skip any all-5 row).\n2. For each zone (between columns of 5\u2019s), find the \"middle\" row(s) that contains nonzero digits other than 5. For each of these, record the nonzero digits in that region and note their order from left to right.\n3. For each such region, assign a distinct color/number to the region. The sequence is: the leftmost region gets min color (in these examples, 6 or 7), the next region gets the next value in sequence, etc. The assigned number for each region is determined as 4 plus the nonzero digit in the \"middle\" non-5 row(s). For example, if the nonzero digit is 2, assign 6; if 3, assign 7; if 4, assign 8; if 1, assign 5; etc. (That is, resulting color = 4 + original digit, for nonzero digits in the row.)\n4. Replace all non-5, nonzero numbers in the central row of each zone with the region's new assigned color. Then, for each region, fill every non-5 cell in that region (above and below, within the zone) with this assigned color.\n5. Leave columns of 5's and any all-5 rows unchanged.", "test_input": [[0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 2, 0, 5, 0, 3, 0, 5, 0, 4, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 1, 0, 5, 0, 1, 0, 5, 0, 3, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0],\n [0, 6, 0, 5, 0, 7, 0, 5, 0, 8, 0],\n [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0],\n [0, 5, 0, 5, 0, 5, 0, 5, 0, 7, 0],\n [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0]]", "expected_output": [[7, 7, 7, 5, 8, 8, 8, 5, 9, 9, 9], [7, 7, 7, 5, 8, 8, 8, 5, 9, 9, 9], [7, 7, 7, 5, 8, 8, 8, 5, 9, 9, 9], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 5, 6, 6, 6, 5, 8, 8, 8], [6, 6, 6, 5, 6, 6, 6, 5, 8, 8, 8], [6, 6, 6, 5, 6, 6, 6, 5, 8, 8, 8]]}, "54db823b": {"instruction": "1. For each row in the grid, identify the leftmost nonzero sequence of contiguous 3s, 9s, and/or surrounded 3-9 clusters (ignoring leading zeros). Define the \"significant block\" for that row as the run from the first nonzero up to (and including) the last nonzero before the first stretch of two or more contiguous zeros starts.\n2. For every cell in the row that comes after this significant block (i.e., to its right), set its value to 0 (except possible trailing zeros which will already be 0).\n3. Leave the significant block and any cells to its left unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 9, 3, 0, 3, 9, 3, 3, 3, 0], [0, 0, 3, 9, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 3, 3, 3, 9, 0, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0, 3, 3, 9, 3, 3, 0], [3, 9, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 9, 3, 9, 3, 0, 3, 3, 9, 9, 3, 0, 0, 0, 0], [3, 3, 9, 3, 3, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 3, 9, 3, 9, 3, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 9], [3, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3], [3, 9, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 9], [9, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0],\n [0, 0, 3, 3, 3, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 3, 9, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 3, 3, 3, 3, 3, 9, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0],\n [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 9, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 9, 3, 9, 3, 0, 3, 3, 9, 9, 3, 0, 0, 0, 0],\n [3, 3, 9, 3, 3, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],\n [3, 3, 3, 3, 3, 0, 3, 9, 3, 9, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0],\n [3, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 9, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [9, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 9, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 9, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 9, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 9, 3, 9, 3, 0, 3, 3, 9, 9, 3, 0, 0, 0, 0], [3, 3, 9, 3, 3, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 3, 9, 3, 9, 3, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 9], [3, 3, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3], [3, 9, 3, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 9, 9], [9, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3]]}, "54dc2872": {"instruction": "1. Identify the largest contiguous group of nonzero cells in the input grid; this group will appear as a \"block\" with the same number in a connected horizontal or vertical shape.\n2. Remove this group from its original location in the grid by replacing all of its cells with 0.\n3. Relocate this group such that its topmost cell is in the second row (row index 1) and its leftmost cell is in the leftmost possible column (while preserving the group's original shape).\n4. All other cells in the grid remain unchanged.", "test_input": [[0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 3, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 8, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 7, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 8, 6, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0], [3, 5, 0, 0, 0, 0, 7, 3, 0, 0, 0, 0, 0], [3, 3, 3, 0, 0, 0, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0]]}, "55059096": {"instruction": "1. For each horizontal line segment of contiguous '3's of length 3 or greater, identify the center cell(s) of the segment. For odd-length segments, take the single center cell; for even-length segments of length \u22654, mark the two central cells.\n2. Starting from the center cell(s) of the horizontal segment, trace a vertical line downwards (increasing row index) and upwards (decreasing row index), skipping all '0's, until you hit:\n   - A nonzero cell (i.e., a '3') not part of the current segment, OR\n   - The edge of the grid, OR\n   - Another horizontal segment of '3's.\n3. For each row directly on the vertical path between segments, color the cell in the same column as the center of the segment with '2' except where the cell is part of a segment of '3's (do not overwrite '3's).\n4. Repeat for all horizontal segments of '3's of length 3 or more, connecting to any segments above or below if they exist in the same (center) column.", "test_input": [[0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 3, 3, 3, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0]]", "expected_output": [[0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "551d5bf1": {"instruction": "1. For each row in the input grid, identify all enclosed areas formed by '1's, where an enclosed area is defined by '0's that are completely surrounded horizontally and vertically (not diagonally) by '1's within a continuous boundary.\n2. Replace every '0' within such an enclosed area by '8'. An enclosed area must be fully surrounded by '1's, not touching the border of the grid or any outer non-surrounded area of '0's.\n3. If a column contains an enclosed region bounded by '1's (as sometimes happens vertically, such as in vertical rectangles), similarly fill every '0' within that bounded region with '8'.\n4. All other values (including '1's and '0's outside of these bounded regions) remain unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0],\n [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0],\n [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 1, 1, 8, 1, 1, 1, 1, 1, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0], [0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 1, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 8, 1, 1, 0, 0, 0], [0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 8, 1, 1, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0]]}, "5521c0d9": {"instruction": "1. Identify all distinct vertically aligned blocks of contiguous nonzero values (rectangles of 1s, 2s, or 4s) in the input grid. For each color block, note its bounding box (minimal enclosing rectangle).\n2. Move each color block upward or downward so that it occupies the earliest available rows in the grid, preserving left-right (column) positions and the vertical order/spacing observed in other examples:\n   - The topmost block in the group (in the input) becomes the topmost nonzero block in the output, starting from the first available row.\n   - Each subsequent block appears immediately beneath the prior (with preserved spacing if other blocks were present between them in the input).\n3. All cells that do not belong to a detected color block are set to zero.\n4. The overall result is that color blocks are stacked in vertical order, from top to bottom, in their respective columns, and all other areas are zero.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1]], "predicted_output": "[[2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1],\n [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1],\n [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1],\n [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "5582e5ca": {"instruction": "1. Identify the center cell of the input grid (i.e., the cell at position [1, 1] in a 3x3 grid).  \n2. Replace every cell in the grid with the value of this center cell.", "test_input": [[8, 8, 6], [4, 6, 9], [8, 3, 0]], "predicted_output": "[[6, 6, 6],\n [6, 6, 6],\n [6, 6, 6]]", "expected_output": [[8, 8, 8], [8, 8, 8], [8, 8, 8]]}, "5587a8d0": {"instruction": "1. Identify all non-background colors present in the input grid. The background color is the most frequent color (in these examples, typically 7).\n2. For each distinct connected component (contiguous region) of each non-background color, note its position and shape. \n3. Reconstruct a new square grid whose size equals the length of the longest side among the bounding boxes of all non-background regions (component groupings). The smallest grid size sufficient to contain all such regions, centered.\n4. Arrange the regions/components within the new grid by stacking or nesting them so that:\n   - The border of the new grid is filled with the color that forms the outermost region in the input (often from the largest contiguous background boundary in the input, or inferred from context).\n   - The next inner border is filled with the color that forms the next inner region in the input.\n   - Continue nesting, placing each next color inside the previous, based on their degree of containment or adjacency in the input.\n   - Any original inner smaller regions appear centered or positioned within the new grid in proportion to their original relative position inside their parent region.\n5. Fill all interior empty cells (not part of a colored region) with the color from the next 'outer' region, maintaining the nested structure.", "test_input": [[7, 7, 9, 7, 7, 2, 2, 2], [7, 7, 9, 7, 7, 2, 7, 2], [5, 7, 7, 7, 7, 7, 7, 7], [5, 5, 7, 8, 7, 7, 7, 7], [5, 7, 7, 7, 7, 0, 7, 7], [7, 7, 1, 7, 7, 0, 0, 7], [7, 1, 1, 1, 7, 7, 0, 0], [1, 1, 1, 1, 1, 7, 7, 0]], "predicted_output": "[[7, 7, 7, 7, 7, 7, 7, 7],\n [7, 5, 5, 5, 5, 5, 5, 7],\n [7, 5, 1, 1, 1, 1, 5, 7],\n [7, 5, 1, 0, 0, 1, 5, 7],\n [7, 5, 1, 0, 0, 1, 5, 7],\n [7, 5, 1, 1, 1, 1, 5, 7],\n [7, 5, 5, 5, 5, 5, 5, 7],\n [7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 2, 2, 2, 2, 2, 2, 2, 0, 1], [1, 0, 2, 5, 5, 5, 5, 5, 2, 0, 1], [1, 0, 2, 5, 9, 9, 9, 5, 2, 0, 1], [1, 0, 2, 5, 9, 8, 9, 5, 2, 0, 1], [1, 0, 2, 5, 9, 9, 9, 5, 2, 0, 1], [1, 0, 2, 5, 5, 5, 5, 5, 2, 0, 1], [1, 0, 2, 2, 2, 2, 2, 2, 2, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, "5614dbcf": {"instruction": "1. Divide the input grid into three equal-sized 3x3 sub-grids: top-left, center, and bottom-right.\n2. For each 3x3 sub-grid:\n    a. Find the center cell of the 3x3 sub-grid (i.e., the cell at position [1,1] within the local 3x3 window).\n    b. Copy the value of this center cell to the corresponding position in the output grid, keeping the same relative location (top-left, center, or bottom-right).\n    c. Set all other cells in the 3x3 output grid to 0.\n3. Assemble the three center values into a new 3x3 output grid, where each is positioned as in its original sub-grid (top-left, center, bottom-right). All other cells in the output grid remain 0.", "test_input": [[4, 4, 4, 0, 0, 0, 0, 5, 0], [5, 4, 4, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 5, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 5, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 5, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 0, 0, 0]], "predicted_output": "[[4, 0, 0],\n [0, 3, 0],\n [0, 0, 9]]", "expected_output": [[4, 0, 0], [0, 3, 0], [0, 9, 0]]}, "5623160b": {"instruction": "1. For each non-background connected block of colored cells (i.e., groups of adjacent non-7 cells), shift the entire block toward the topmost available row in its current column while preserving the block\u2019s shape and horizontal alignment. If there is another block above, place the current block just below the lowest occupied cell of that column or adjacent block to prevent overlap.\n2. After the upward shifting, check if any block now touches the top of the grid or another non-background element above it\u2014do not shift further in that case.\n3. Repeat this shifting for all distinct connected objects and all columns, until every connected block is in its \"floating\" position as high as possible without overlap.", "test_input": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7], [7, 7, 5, 5, 5, 5, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7], [7, 7, 5, 7, 7, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 5, 7, 7, 7, 7, 5, 5, 5, 7, 7, 7, 7, 7, 7], [7, 7, 5, 5, 5, 7, 7, 5, 7, 5, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 8, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 3, 9, 9, 8, 7, 7, 7, 7], [7, 7, 7, 9, 7, 7, 7, 7, 7, 6, 0, 7, 7, 7, 7, 7], [7, 7, 7, 9, 7, 7, 7, 7, 7, 7, 0, 0, 7, 7, 7, 7], [7, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7], [7, 4, 7, 9, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 7, 7], [7, 7, 2, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[7, 7, 5, 5, 5, 5, 7, 5, 5, 7, 7, 7, 9, 7, 7, 7],\n [7, 7, 5, 7, 7, 5, 5, 5, 7, 7, 7, 7, 9, 7, 7, 7],\n [7, 7, 5, 7, 7, 7, 7, 5, 5, 5, 7, 7, 9, 9, 7, 7],\n [7, 7, 5, 5, 5, 7, 7, 5, 7, 5, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 3, 9, 9, 8, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 8, 7, 7, 7, 7],\n [7, 7, 7, 9, 7, 7, 7, 7, 7, 6, 0, 7, 7, 7, 7, 7],\n [7, 7, 7, 9, 7, 7, 7, 7, 7, 7, 0, 0, 7, 7, 7, 7],\n [7, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7],\n [7, 4, 7, 9, 7, 7, 7, 7, 7, 7, 0, 0, 0, 0, 7, 7],\n [7, 7, 2, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[7, 7, 5, 5, 5, 5, 7, 5, 5, 7, 7, 7, 7, 7, 7, 7], [7, 7, 5, 7, 7, 5, 5, 5, 7, 7, 7, 7, 9, 7, 7, 7], [7, 7, 5, 7, 7, 7, 7, 5, 5, 5, 7, 7, 9, 7, 7, 7], [7, 7, 5, 5, 5, 7, 7, 5, 7, 5, 7, 7, 9, 9, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 8], [3, 7, 7, 7, 7, 7, 7, 7, 7, 9, 9, 7, 7, 7, 7, 8], [7, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 9, 9, 9, 9, 9, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7], [7, 7, 7, 9, 7, 7, 7, 7, 7, 7, 0, 0, 7, 7, 7, 7], [2, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7, 0, 7, 0, 7, 7], [7, 4, 7, 7, 7, 7, 7, 7, 7, 6, 0, 0, 0, 0, 7, 7]]}, "56dc2b01": {"instruction": "1. Identify the rows containing the contiguous group of '3's (the figure). In the input, these are the right-most columns with nonzero values (colors '3').\n2. Remove these figure-rows entirely from their original position in the grid.\n3. Insert the removed figure-rows immediately beneath the last full horizontal row of '2's, maintaining the original order of the rows and their horizontal alignment.\n4. In the row immediately beneath the newly placed figure-rows, insert a new row where all cells are set to '8'.\n5. Fill the original positions of the removed figure-rows with entirely '0's to maintain grid size and shape.\n6. All other rows and values, including those containing '2's, remain unchanged and in their original positions.", "test_input": [[0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[0, 0, 0, 0, 2, 0, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 0, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "56ff96f3": {"instruction": "1. Identify all nonzero cells in the input grid. For each unique nonzero value, treat those cells as the \"seed\" or anchor for a rectangle of that value.\n2. For each set of connected seed cells of the same value (connected either directly or by sharing a row or column):\n   a. Find the bounding rectangle that includes all of the seed cells of that value (i.e., the smallest rectangle that covers all of them).\n   b. Expand this rectangle rightward and downward such that its width and height are both equal to the distance (inclusive) between the leftmost and rightmost seed columns, and the topmost and bottommost seed rows, respectively, or at least 3x3 if there are multiple seeds present (if only one seed, expand to form a 3x3 rectangle unless at edge of the grid).\n   c. If there are only two seed cells that are not aligned in the same row or column, make the rectangle from the topmost/leftmost seed position to the bottommost/rightmost position (inclusive).\n3. Fill the entire rectangle for each value with that value.\n4. All other cells remain as 0.", "test_input": [[8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[8, 8, 8, 0, 0, 0, 0, 0],\n [8, 8, 8, 0, 0, 0, 0, 0],\n [8, 8, 8, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 6, 6, 6],\n [0, 0, 0, 0, 0, 6, 6, 6],\n [0, 0, 0, 0, 0, 6, 6, 6],\n [0, 6, 6, 6, 0, 0, 0, 0],\n [0, 6, 6, 6, 0, 0, 0, 0],\n [0, 6, 6, 6, 0, 0, 0, 0]]", "expected_output": [[8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, "5751f35e": {"instruction": "1. Identify the minimum rectangle that contains all non-background values (non-0 values) in the input grid.\n2. Expand this rectangle by 1 cell in every direction, forming a new bounding rectangle (ensuring it stays within the grid bounds).\n3. Set the boundary of this expanded rectangle to the \"frame color\"\u2014which is the most common color found at the original grid boundary (in this case, 4).\n4. Fill the inner area (all cells entirely inside the boundary, excluding the border) as follows:\n    a. For each cell inside the border, if it was a 1, 3, or 4 in the input, map it as:\n        - If it was 1 or 3, set to 3.\n        - If it was 4, set to 4.\n    b. All other inner cells (including where there was a 0 in the input) set to 1.\n5. Leave all cells outside the expanded rectangle as background (0).", "test_input": [[4, 0, 0, 0, 0, 4, 0, 4, 4, 0, 4, 0], [0, 4, 0, 0, 0, 0, 4, 4, 0, 4, 4, 4], [4, 4, 0, 3, 3, 0, 3, 3, 3, 3, 0, 0], [4, 0, 3, 0, 3, 0, 3, 0, 3, 0, 4, 4], [0, 4, 3, 3, 0, 1, 1, 0, 3, 3, 0, 4], [0, 4, 0, 3, 1, 0, 1, 0, 0, 3, 4, 0], [0, 0, 3, 3, 1, 1, 1, 1, 0, 3, 0, 4], [0, 4, 3, 0, 0, 1, 0, 1, 3, 3, 0, 4], [4, 4, 3, 3, 3, 3, 0, 0, 0, 3, 0, 0], [0, 0, 3, 0, 3, 3, 0, 0, 3, 3, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0], [4, 0, 4, 4, 0, 4, 0, 0, 4, 4, 0, 4]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0],\n [0, 4, 3, 1, 1, 3, 1, 3, 3, 3, 4, 0],\n [0, 4, 1, 4, 3, 1, 3, 1, 3, 4, 4, 0],\n [0, 4, 3, 3, 1, 3, 3, 1, 3, 3, 4, 0],\n [0, 4, 1, 3, 3, 1, 3, 1, 1, 3, 4, 0],\n [0, 4, 3, 3, 3, 3, 3, 3, 1, 3, 4, 0],\n [0, 4, 3, 1, 1, 3, 1, 3, 3, 3, 4, 0],\n [0, 4, 3, 3, 3, 3, 1, 1, 1, 3, 4, 0],\n [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4], [4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4], [4, 4, 3, 3, 1, 1, 1, 1, 3, 3, 4, 4], [4, 4, 3, 3, 1, 1, 1, 1, 3, 3, 4, 4], [4, 4, 3, 3, 1, 1, 1, 1, 3, 3, 4, 4], [4, 4, 3, 3, 1, 1, 1, 1, 3, 3, 4, 4], [4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4], [4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]}, "575b1a71": {"instruction": "1. Scan the input grid for all occurrences of the value 0. For each 0 found, determine its column index.\n2. Replace each 0 with a new value based on its column index:\n   - If the column index is 0, replace 0 with 1.\n   - If the column index is 3, replace 0 with 2.\n   - If the column index is 5, replace 0 with 3.\n   - If the column index is 8, replace 0 with 4.\n3. Leave all other values in the grid unchanged.", "test_input": [[5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 0, 5, 5, 5, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 0, 5, 5, 5, 5]], "predicted_output": "[[5, 5, 5, 2, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [1, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 3, 5, 5, 5, 5],\n [5, 5, 2, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 2, 5, 5, 5, 5, 5, 5, 5],\n [1, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [1, 5, 5, 5, 5, 3, 5, 5, 5, 5]]", "expected_output": [[5, 5, 5, 3, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 4, 5, 5, 5, 5], [5, 5, 2, 5, 5, 5, 5, 5, 5, 5], [5, 5, 2, 5, 5, 5, 5, 5, 5, 5], [1, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 5, 5, 5, 5, 4, 5, 5, 5, 5]]}, "5783df64": {"instruction": "1. Identify all nonzero numbers in the input grid. Record the (row, column) positions for each, along with their values.\n2. Divide the positions of the nonzero numbers into three groups based on which horizontal third of the input grid their row belongs to:\n    - Group 1: rows 0 to N/3 - 1 (top third)\n    - Group 2: rows N/3 to 2N/3 - 1 (middle third)\n    - Group 3: rows 2N/3 to N - 1 (bottom third)\n   (Where N is the number of rows in the input grid. Use integer division.)\n3. For each group (top to bottom), collect the nonzero values and order them by increasing column index (left to right within their third).\n4. For each group, form a row in the output grid using these ordered nonzero values, stacking groups from top, middle to bottom to form the output.\n5. The result is a 3-row grid, each row corresponding to the nonzero values found in the corresponding third of the input, ordered left to right as described.", "test_input": [[0, 0, 0, 0, 0, 0, 9, 0, 0], [5, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7]], "predicted_output": "[[5, 6, 9], [1, 4, 8], [2, 3, 7]]", "expected_output": [[5, 6, 9], [4, 1, 8], [3, 2, 7]]}, "5792cb4d": {"instruction": "1. Identify the non-background rectangular region that contains distinct non-8 values (the active area). In this grid, the active area spans rows 1 to 8 and columns 2 to 8.\n2. For every cell in the active area, move the value two steps to the right and two steps down, wrapping within the bounds of the active area. Specifically:\n    - Take the value at position (row, col) in the input's active area.\n    - Place it at position (row + 2, col + 2) in the output's active area.\n    - If this new position is outside the active area bounds, wrap the value around to the start of the range (cyclically within the active area's rows and columns).\n3. Fill any cells outside the active area or those not assigned by the transformation above with the background value of 8.", "test_input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 9, 9, 2, 8], [8, 8, 8, 8, 8, 8, 9, 8, 2, 8], [8, 8, 6, 6, 1, 8, 5, 8, 2, 8], [8, 8, 6, 8, 4, 8, 5, 8, 4, 8], [8, 8, 7, 8, 1, 5, 5, 8, 4, 8], [8, 8, 7, 8, 8, 8, 8, 8, 4, 8], [8, 8, 7, 8, 8, 8, 8, 8, 1, 8], [8, 8, 1, 1, 7, 8, 8, 1, 1, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "predicted_output": "[[8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n [8, 8, 1, 5, 8, 4, 8, 4, 8, 8],\n [8, 8, 8, 4, 8, 1, 5, 8, 2, 8],\n [8, 8, 8, 4, 8, 8, 8, 8, 2, 8],\n [8, 8, 8, 1, 1, 7, 8, 8, 2, 8],\n [8, 8, 6, 6, 7, 8, 9, 9, 2, 8],\n [8, 8, 8, 8, 8, 8, 9, 8, 4, 8],\n [8, 8, 6, 8, 8, 8, 5, 8, 4, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]", "expected_output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 4, 1, 6, 8], [8, 8, 8, 8, 8, 8, 1, 8, 6, 8], [8, 8, 2, 2, 9, 8, 5, 8, 6, 8], [8, 8, 2, 8, 9, 8, 5, 8, 7, 8], [8, 8, 4, 8, 9, 5, 5, 8, 7, 8], [8, 8, 4, 8, 8, 8, 8, 8, 7, 8], [8, 8, 4, 8, 8, 8, 8, 8, 1, 8], [8, 8, 1, 1, 1, 8, 8, 7, 1, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]}, "57aa92db": {"instruction": "1. For each distinct colored shape/block (i.e., group of nonzero, contiguous cells with the same value) in the grid, identify the minimal rectangle that fully contains that block.\n2. For each such block, expand its containing rectangle to the left and/or right so that its width becomes triple what it was originally, centering the original shape within the new width if possible. (If the original block is attached to the grid border, expand away from the border.)\n    - For example, for a horizontal bar of 3 cells, expand it to 9 consecutive cells wide, keeping it on the same row and color. For vertical blocks, expand in width, not height\u2014i.e., horizontally.\n3. Fill any newly added cells during the expansion with the color of that block, maintaining the block's vertical position and height exactly.\n4. Repeat this for all nonzero blocks throughout the grid. Do not expand background zeros or blocks of zeros.\n5. Leave all other grid areas (with value 0) unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 1, 8, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1],\n [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 1, 8, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 4, 4, 4, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 4, 4, 4, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 1, 1, 1, 4, 4, 4, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 0, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 3, 3, 1, 1, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0], [0, 0, 0, 0, 3, 3, 1, 1, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "57edb29d": {"instruction": "1. Divide the input grid horizontally into three major sections, separated by fully filled border rows of the value 4. These will be: the first section at the top (from row 1 to the first fully-4 row, exclusive), the second section in the middle, and the third section at the bottom.\n2. From each section, extract the \"inner\" subgrid embedded within border values (value 4). These will be rectangular \"blocks\" containing distinctive interior patterns and surrounded by a single border of 4s.\n    - For the first section (top): Take the block surrounded by a border of 4s, containing values 1, 5, and 3.\n    - For the second section (middle): Take the block surrounded by a border of 4s, containing values 2, 5, 8, and 9.\n    - For the third section (bottom): Take the block surrounded by a border of 4s, containing values 2, 5, and 7.\n3. For each extracted block:\n    a. Remove the outer border of 4s to reveal the inner pattern.\n4. Arrange the resulting three blocks vertically, in the order they appeared in the original grid (top section's block first, then middle, then bottom), to form a new grid.\n5. The output grid is the vertical concatenation of these three de-bordered blocks.", "test_input": [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4], [4, 1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 4, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 4], [4, 1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 4, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 4], [4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4], [4, 1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 4, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 4], [4, 1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 4, 3, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 4], [4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 4, 8, 5, 8, 8, 8, 8, 8, 5, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 4, 8, 5, 8, 8, 8, 8, 8, 5, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 5, 8, 8, 8, 8, 8, 5, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 5, 8, 8, 8, 8, 8, 5, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 9, 9, 9, 9, 9, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4], [4, 2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 4, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 4], [4, 2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 4, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "predicted_output": "[[1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1],\n [1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 1],\n [1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 1],\n [1, 5, 1, 1, 1, 1, 1, 1, 5, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 8, 5, 8, 8, 8, 8, 8, 5, 8, 9, 9, 9, 9, 9],\n [2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 8, 5, 8, 8, 8, 8, 8, 5, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 5, 8, 8, 8, 8, 8, 5, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 5, 8, 8, 8, 8, 8, 5, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7],\n [2, 5, 2, 2, 2, 2, 2, 2, 5, 2, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[9, 9, 9, 9, 9], [9, 5, 9, 5, 9], [9, 5, 9, 5, 9], [9, 9, 9, 9, 9], [9, 9, 9, 9, 9], [9, 9, 9, 9, 9], [9, 5, 9, 5, 9], [9, 5, 9, 5, 9], [9, 9, 9, 9, 9]]}, "5833af48": {"instruction": "1. Remove all rows and columns that are completely filled with zeros (i.e., trim the empty border).\n2. From the remaining grid, identify the top nonzero region (\u201cpattern region\u201d) that is vertically separated from the block of background color (e.g., a shape or motif in the upper area).\n3. Identify the bottom nonzero region that forms a solid rectangle of a color different from the pattern color (the \"base block\").\n4. Count the number of rows in the base block; this determines the height of the output grid.\n5. Starting from the leftmost nonzero block in the base block, crop the base block to the minimum rectangle containing all its nonzero cells. This determines the width of the output grid.\n6. Downscale the pattern region (excluding the base block) to fit within the base block's dimensions, so its center aligns with the base, and each output row corresponds to one pattern row (map pattern proportionally if needed).\n7. In this shrunken pattern, replace all non-background, non-special-color cells (i.e., all pattern cells except for unique cells like 8) with the solid color from the base block.\n8. Retain every \u201c8\u201d in the same position in the shrunk pattern.\n9. Assemble the new grid: overlay the shrunken pattern (with \u201c8\u201ds) onto a grid filled with the base block's color.\n10. The final output is the shrunken, merged grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 8, 2, 8, 0, 1, 8, 1, 1, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 2, 2, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 8, 8, 0, 1, 8, 1, 1, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 2, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1],\n [1, 1, 8, 8, 1, 8, 1, 1, 1, 8, 1, 8, 1, 8, 1],\n [1, 8, 1, 1, 8, 8, 1, 8, 1, 8, 8, 1, 8, 8, 1],\n [1, 1, 1, 8, 1, 8, 1, 1, 1, 8, 1, 8, 1, 8, 1],\n [1, 1, 8, 8, 1, 8, 8, 1, 8, 8, 1, 1, 8, 8, 1],\n [1, 1, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]", "expected_output": [[1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1], [1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 8, 1, 1, 1, 1], [1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8], [8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1], [1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8], [8, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 8], [1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 1, 1, 1, 1], [1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 8, 8, 1, 1, 1, 1]]}, "58743b76": {"instruction": "1. For each cell in the grid that contains the value 1 and is not in the bottom two rows or rightmost columns that are filled with border values (such as 8, 3, 1, 7, or 4), determine its position within the inner non-border region of the grid.\n2. Replace each value 1 with a value according to its row position, cycling through the sequence [4, 6, 2] as seen in previous examples:\n   - For the first appearance of a 1 in a given column (from top to bottom in the non-border region), replace it with 4.\n   - For the second appearance in that column, replace it with 6.\n   - For the third, replace it with 2.\n   - If there are additional 1s, repeat the cycle [4, 6, 2].\n3. Leave all other values unchanged.\n4. Preserve the outer border region unchanged (values of 8 or other border values in the rightmost columns and bottom two rows).", "test_input": [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 8, 8], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 8], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 8, 8], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 1], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 4]], "predicted_output": "[[0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 6, 0, 0, 0, 4, 0, 4, 0, 0, 8, 8],\n [4, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [6, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 8, 8],\n [0, 0, 0, 0, 0, 0, 0, 2, 6, 0, 0, 0, 8, 8],\n [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 1],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 4]]", "expected_output": [[0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 8, 8], [3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 8], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [7, 0, 0, 0, 0, 7, 0, 0, 4, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 4, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 8, 8], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 1], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 4]]}, "58c02a16": {"instruction": "1. Identify the smallest contiguous non-background (not 7) block in the top-left of the grid. This \"motif\" block is a square or rectangle going from (0,0) to the first all-background row and column. (In this example, it's the 4x4 block in the upper left.)\n2. Repeat this motif to fill the entire grid in a tile pattern, such that for each grid cell (i,j), its value is set to motif[i % motif_height][j % motif_width], where motif_height and motif_width are the size of the identified motif.\n3. Keep all positions that would have been background (7) in the motif as background in the tiling.", "test_input": [[4, 7, 4, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [4, 4, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [4, 7, 4, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5, 4, 4, 7, 5],\n [4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5, 4, 7, 4, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]", "expected_output": [[4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 4, 7, 5, 5, 7, 4, 4, 7, 4, 4, 7, 5, 5, 7, 4], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 7, 4, 4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5], [4, 4, 7, 4, 4, 7, 5, 5, 7, 4, 4, 7, 4, 4, 7, 5], [4, 7, 4, 4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 4, 7, 5, 5, 7, 4, 4, 7, 4, 4, 7, 5, 5, 7, 4], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 4, 7, 5, 5, 7, 4, 4, 7, 4, 4, 7, 5, 5, 7, 4], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4], [4, 7, 4, 4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5], [4, 4, 7, 4, 4, 7, 5, 5, 7, 4, 4, 7, 4, 4, 7, 5], [4, 7, 4, 4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5], [4, 7, 4, 5, 7, 5, 4, 7, 4, 4, 7, 4, 5, 7, 5, 4]]}, "58e15b12": {"instruction": "1. Locate the columns in the input grid that contain vertical stacks of the same color. In this case, find columns containing vertical stacks of color 3 and columns containing vertical stacks of color 8.\n2. For columns containing vertical stacks of color 3 (in this grid, columns 11 and 16, rows 3\u20135), copy this vertical stack to all possible diagonals that start from every row of the grid and move toward the bottom-left, placing the color 3 on the diagonal cells. That is, for each original 3 in (row, col), for n in 0...row, set (row-n, col-n) to 3, provided coordinates are valid.\n3. For columns containing vertical stacks of color 8 (in this grid, columns 5 and 8, rows 10\u201314), for each original 8 in (row, col), copy this position to all possible diagonals that start from every row of the grid and move toward the top-right, placing the color 8 on the diagonal cells. That is, for each 8 in (row, col), for n in 0...number of rows below, set (row+n, col+n) to 8, provided coordinates are valid.\n4. All other cells remain zero.\n5. If any cell gets assigned both 3 and 8 due to diagonal overlap, priority can be given to either color according to the observed output (choose the most recent assignment as seen in the output examples, which is typically the last diagonal written).", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 8, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 8, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 8, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 8, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 3, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 3, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "59341089": {"instruction": "1. For each row in the input grid, repeat the following steps until all rows are processed:  \n2. For each cell in the row (i.e., for each input cell at position [i, j]), append four consecutive output cells horizontally, corresponding to the following pattern:\n    - The first cell in the output mini-block is the value to the immediate left of input cell [i, j] (wrapping around the row).\n    - The next two cells in the output block are the value at [i, j] in the input.\n    - The fourth cell in the output block is the value to the immediate right of input cell [i, j] (wrapping around the row).\n3. Concatenate the mini-blocks for each input cell in the row to produce the output row. Do this for every row in the grid.\n4. Stack the output rows to form the complete output grid.", "test_input": [[8, 5, 7], [5, 7, 5], [8, 8, 5]], "predicted_output": "[[5, 8, 8, 5, 7, 5, 5, 7, 5, 7, 7, 5],\n [5, 5, 5, 7, 7, 5, 5, 7, 5, 5, 5, 5],\n [5, 8, 8, 8, 8, 8, 8, 5, 5, 8, 8, 5]]", "expected_output": [[7, 5, 8, 8, 5, 7, 7, 5, 8, 8, 5, 7], [5, 7, 5, 5, 7, 5, 5, 7, 5, 5, 7, 5], [5, 8, 8, 8, 8, 5, 5, 8, 8, 8, 8, 5]]}, "5a5a2103": {"instruction": "1. Divide the grid into equal-width vertical stripes using the full-width rows (the rows that are filled completely with the same nonzero color; e.g., 5s). Each stripe is bounded by these rows and is of equal width.\n2. For each stripe, take all the rows between each pair of full-width boundary rows; these subgrids represent blocks to be transformed.\n3. For each block:\n    a. Identify the color that appears most in the left portion of the block (usually, this color forms a 2x2 block near the left; e.g., \"2\" or \"3\", etc.).\n    b. Replace the corresponding cell patterns for this color, originally present only on the left, in all horizontal positions of the block, except in columns occupied by boundary or fixed colors (e.g., keep vertical \"5\" boundaries intact).\n    c. The pattern for each color is:\n        - Row 1: [color, color, 0, color]\n        - Row 2: [0, color, color, 0]\n        - Row 3: [color, color, color, color]\n        - Row 4: [0, color, 0, 0]\n       The width and height may vary if the block is larger or smaller, but the basic pattern is a 2x2 block top-left, and patterns echo horizontally across the non-boundary area.\n    d. Repeat this pattern horizontally, filling all available blocks between boundary columns without overwriting any existing vertical boundaries or nonzero border colors.\n4. Leave the boundary (full-width) rows unchanged.\n5. Repeat for each subsequent block/stripe.", "test_input": [[0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 2, 2, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 2, 2, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 1, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 3, 3, 0, 5, 0, 0, 0, 0, 5, 1, 1, 1, 1, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 3, 3, 0, 5, 0, 0, 0, 0, 5, 0, 1, 1, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 1, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 4, 4, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 4, 4, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 6, 6, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 6, 6, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 7, 7, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 7, 7, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0],\n [2, 2, 0, 2, 5, 2, 2, 0, 2, 5, 2, 2, 0, 2, 5, 2, 2, 0, 2, 5, 2, 2, 0, 2],\n [0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0],\n [2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [3, 3, 0, 3, 5, 3, 3, 0, 3, 5, 3, 3, 0, 3, 5, 3, 3, 0, 3, 5, 3, 3, 0, 3],\n [0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0],\n [3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3],\n [0, 3, 0, 0, 5, 0, 3, 0, 0, 5, 0, 3, 0, 0, 5, 0, 3, 0, 0, 5, 0, 3, 0, 0],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [4, 4, 0, 4, 5, 4, 4, 0, 4, 5, 4, 4, 0, 4, 5, 4, 4, 0, 4, 5, 4, 4, 0, 4],\n [0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0],\n [4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4],\n [0, 4, 0, 0, 5, 0, 4, 0, 0, 5, 0, 4, 0, 0, 5, 0, 4, 0, 0, 5, 0, 4, 0, 0],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [6, 6, 0, 6, 5, 6, 6, 0, 6, 5, 6, 6, 0, 6, 5, 6, 6, 0, 6, 5, 6, 6, 0, 6],\n [0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0],\n [6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6],\n [0, 6, 0, 0, 5, 0, 6, 0, 0, 5, 0, 6, 0, 0, 5, 0, 6, 0, 0, 5, 0, 6, 0, 0],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n [7, 7, 0, 7, 5, 7, 7, 0, 7, 5, 7, 7, 0, 7, 5, 7, 7, 0, 7, 5, 7, 7, 0, 7],\n [0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0],\n [7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7],\n [0, 7, 0, 0, 5, 0, 7, 0, 0, 5, 0, 7, 0, 0, 5, 0, 7, 0, 0, 5, 0, 7, 0, 0]]", "expected_output": [[0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0], [2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2, 5, 2, 2, 2, 2], [0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0, 5, 0, 2, 2, 0], [0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0, 5, 0, 0, 2, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0], [3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3, 5, 3, 3, 3, 3], [0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0, 5, 0, 3, 3, 0], [0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0, 5, 0, 0, 3, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0], [4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 4], [0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0, 5, 0, 4, 4, 0], [0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0, 5, 0, 0, 4, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0], [6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6, 5, 6, 6, 6, 6], [0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0, 5, 0, 6, 6, 0], [0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0, 5, 0, 0, 6, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0], [7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7, 5, 7, 7, 7, 7], [0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0, 5, 0, 7, 7, 0], [0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0, 5, 0, 0, 7, 0]]}, "5a719d11": {"instruction": "1. For each non-empty region (block) in the grid separated by all-zero rows or columns, process it independently.\n2. Within each region, identify all unique non-background colors (the \"background\" being the dominant color forming the solid blocks, with zero as the separator; e.g., in the first region, 8 is the background).\n3. In each region, replace every non-background, non-zero pixel with the region's background color, *except* for pixels that are in the same row or column as another non-background, non-zero color (indicating a line or block of such colors). These pixels should become the secondary color for the region, defined as:  \n   - The color in the region that is different from both background and zero, and always forms lines or embedded blocks in the input (for example, in the first region, we see lines/blocks of 1s and 7s; these become 4 in the output).\n   - If there are multiple such colors in the input, pick the one that replaces the majority of colorful pixels in the training examples (for this input grid, use color 4 for the first region, 3 for the second, 9 for the third, and 1 for the fourth).\n4. Isolated colorful single pixels that are not members of such a line or block should also be converted to the background color, per the pattern in the output examples.\n5. Leave all zero (background-separating) rows and columns unchanged.", "test_input": [[8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4], [8, 1, 8, 1, 1, 1, 8, 0, 0, 4, 7, 7, 4, 4, 7, 4], [8, 1, 1, 1, 8, 8, 8, 0, 0, 4, 4, 7, 7, 7, 7, 4], [8, 1, 8, 1, 1, 1, 8, 0, 0, 4, 4, 4, 4, 4, 7, 4], [8, 1, 8, 8, 8, 1, 8, 0, 0, 4, 4, 4, 4, 4, 7, 4], [8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3], [2, 8, 8, 2, 2, 2, 2, 0, 0, 3, 9, 9, 9, 9, 9, 3], [2, 2, 8, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 9, 3], [2, 2, 8, 8, 8, 8, 2, 0, 0, 3, 3, 3, 3, 3, 9, 3], [2, 2, 8, 2, 2, 2, 2, 0, 0, 3, 9, 9, 9, 9, 9, 3], [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9], [4, 6, 6, 4, 4, 6, 4, 0, 0, 9, 1, 9, 9, 9, 1, 9], [4, 6, 4, 4, 4, 4, 4, 0, 0, 9, 1, 1, 1, 1, 1, 9], [4, 4, 4, 4, 4, 6, 4, 0, 0, 9, 9, 9, 1, 9, 9, 9], [4, 6, 4, 4, 6, 6, 4, 0, 0, 9, 9, 9, 1, 9, 9, 9], [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 3, 1, 1, 1, 1, 0, 0, 1, 5, 5, 5, 1, 1, 1], [1, 1, 3, 1, 1, 1, 1, 0, 0, 1, 1, 5, 1, 1, 5, 1], [1, 3, 3, 3, 3, 3, 1, 0, 0, 1, 1, 5, 1, 1, 5, 1], [1, 1, 3, 1, 1, 3, 1, 0, 0, 1, 5, 5, 5, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1]], "predicted_output": "[[8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [8, 4, 8, 4, 4, 4, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [8, 4, 4, 4, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [8, 4, 8, 4, 4, 4, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [8, 4, 8, 8, 8, 4, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [4, 9, 9, 4, 4, 9, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [4, 9, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [4, 4, 4, 4, 4, 9, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [4, 9, 4, 4, 9, 9, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1],\n [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1]]", "expected_output": [[8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4], [8, 4, 4, 8, 8, 4, 8, 0, 0, 4, 8, 4, 8, 8, 8, 4], [8, 8, 4, 4, 4, 4, 8, 0, 0, 4, 8, 8, 8, 4, 4, 4], [8, 8, 8, 8, 8, 4, 8, 0, 0, 4, 8, 4, 8, 8, 8, 4], [8, 8, 8, 8, 8, 4, 8, 0, 0, 4, 8, 4, 4, 4, 8, 4], [8, 8, 8, 8, 8, 8, 8, 0, 0, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3], [2, 3, 3, 3, 3, 3, 2, 0, 0, 3, 2, 2, 3, 3, 3, 3], [2, 2, 2, 2, 2, 3, 2, 0, 0, 3, 3, 2, 3, 3, 3, 3], [2, 2, 2, 2, 2, 3, 2, 0, 0, 3, 3, 2, 2, 2, 2, 3], [2, 3, 3, 3, 3, 3, 2, 0, 0, 3, 3, 2, 3, 3, 3, 3], [2, 2, 2, 2, 2, 2, 2, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9], [4, 9, 4, 4, 4, 9, 4, 0, 0, 9, 4, 4, 9, 9, 4, 9], [4, 9, 9, 9, 9, 9, 4, 0, 0, 9, 4, 9, 9, 9, 9, 9], [4, 4, 4, 9, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 4, 9], [4, 4, 4, 9, 4, 4, 4, 0, 0, 9, 4, 9, 9, 4, 4, 9], [4, 4, 4, 4, 4, 4, 4, 0, 0, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1]]}, "5ad4f10b": {"instruction": "1. Identify all non-background unique colors in the grid (ignoring 0, the background). In this case, identify the color '4' and the color '8'.\n2. For each non-background color, extract a 3x3 region for the output grid using the following method:\n    a. Find all locations (row, col) in the input containing this color.\n    b. Reshape these locations spatially into a 3x3 matrix using their distribution. If more than 9 such pixels, use the upper-leftmost cluster of 3x3 to represent the count and pattern, or otherwise select a pattern consistent with the examples (usually the top-leftmost).\n    c. Fill the output 3x3 grid such that presence of the color at a location reflects how it would appear in the 3x3 matrix pattern taken from the input distribution.\n3. Place the extracted patterns into the output grid as follows: The first detected non-background color (in increasing color value order, or top-left most) occupies the top-left corner, the next color fills in the remaining places according to the same logic as the training examples.\n4. The final output should be a 3x3 grid where the presence and placement of each color directly reflects their corresponding 3x3 cluster sampled from the input.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 8, 8, 8, 8, 4, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 4, 0, 0, 0, 0, 4, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 4], [0, 4, 0, 4, 4, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0]], "predicted_output": "[[4, 0, 0],\n [0, 4, 0],\n [0, 0, 8]]", "expected_output": [[4, 0, 4], [0, 4, 4], [0, 0, 4]]}, "5ad8a7c0": {"instruction": "1. For each row in the grid (excluding the first and last rows), check if the row contains exactly two cells with the value '2' that are located in columns 1 and (N-2) (where N is the number of columns), and all other cells are '0'. If so, change all cells between (and including) those two '2's to '2' (i.e., fill the row between the two '2's with '2').\n2. Leave all other rows unchanged.", "test_input": [[2, 0, 0, 0, 0, 2], [0, 2, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 2]], "predicted_output": "[[2, 0, 0, 0, 0, 2],\n [0, 2, 0, 0, 2, 0],\n [0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 0, 2]]", "expected_output": [[2, 0, 0, 0, 0, 2], [0, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 2]]}, "5adee1b2": {"instruction": "1. Identify all nonzero blocks (contiguous regions) of the same color within the grid. For each connected block, treat it as a \"shape.\"\n2. For each shape, create a bounding rectangle tightly encapsulating the nonzero cells of the shape.\n3. For each such rectangle, expand the rectangle by one cell in all four directions (up, down, left, right), but do not expand past the grid boundaries.\n4. For each expanded rectangle, fill the rectangle border (the outermost cells) with a specific color as follows:\n    - Use a new color for the border that is not present within the original shape. This color is consistent across the grid and unique to the particular region (e.g., if the original region was color 2, use color 3 as border; if region 4, use color 2 or another suitable value).\n5. For all internal cells (inside the original bounds, minus the border), fill with the original region's color.\n6. For background cells (not part of any expanded rectangle), leave as 0.\n7. Copy over any special colored cells (e.g., cells marked as '3' or '8') untouched in their original positions.\n8. Retain the overall shape and spatial arrangement of the original patterns, but with the expanded and bordered effect as above.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 4, 4, 0, 4, 4, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0], [0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4], [0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4], [0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4], [0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 3, 3, 0, 0],\n [0, 3, 2, 2, 3, 2, 2, 3, 0, 0, 2, 2, 2, 2, 3, 0, 0, 0, 3, 2, 2, 3, 2, 2, 3, 0],\n [0, 3, 2, 2, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 0],\n [0, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 2, 3, 2, 2, 3, 0],\n [0, 3, 2, 2, 3, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 0, 0, 0, 3, 2, 2, 3, 2, 2, 3, 0],\n [0, 0, 3, 3, 3, 3, 3, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 3, 3, 0, 3, 3, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],\n [0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2],\n [0, 0, 0, 0, 0, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 2, 2, 3, 2, 2, 3, 0, 8, 8, 4, 4, 4, 8, 8, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 3, 3, 2, 2, 2, 3, 3, 0, 8, 4, 4, 0, 4, 4, 8, 0, 0, 3, 2, 2, 3, 2, 2, 3, 0], [0, 3, 3, 2, 0, 2, 3, 3, 0, 8, 8, 4, 0, 4, 8, 8, 0, 0, 3, 3, 2, 2, 2, 3, 3, 0], [0, 3, 2, 2, 0, 2, 2, 3, 0, 8, 8, 4, 0, 4, 8, 8, 0, 0, 3, 3, 2, 0, 2, 3, 3, 0], [0, 3, 3, 2, 2, 2, 3, 3, 0, 8, 4, 4, 4, 4, 4, 8, 0, 0, 3, 2, 2, 0, 2, 2, 3, 0], [0, 3, 3, 3, 3, 3, 3, 3, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 3, 3, 2, 2, 2, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 4, 4], [0, 0, 0, 0, 3, 2, 2, 3, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 0, 4], [0, 0, 0, 0, 3, 3, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 0, 4], [0, 0, 0, 0, 3, 3, 2, 0, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 0, 4], [0, 0, 0, 0, 3, 2, 2, 0, 2, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 4, 4], [0, 0, 0, 0, 3, 3, 2, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 4, 4, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 0, 4, 4, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 0, 4, 8, 8, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 4, 0, 4, 8, 8, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4, 4, 4, 4, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "5af49b42": {"instruction": "1. Identify the bottom-most nonzero row (call this the \"main data row\"). Extract its sequence of nonzero numbers, preserving zeros between clusters of nonzeros.\n2. Partition this main data row into contiguous blocks of nonzero numbers separated by runs of zeros. Each block may consist of one or more numbers; ignore blocks that contain only zeros.\n3. For each nonzero number that appears in the grid above the main data row, locate its grid position, and for each such position:\n    a. Starting from the top row down to the row above the main data row, examine each row for a nonzero number.\n    b. When located, replace the corresponding partition (block) in the main data row that contains this number, copying the entire block upward into the row with the found number, maintaining the same horizontal position (columns) as in the main data row. All other entries in that row should be zero.\n4. After filling all positions as described in step 3, shift each new block horizontally in the destination row to align the leftmost number in the block just to the right of the corresponding earlier block that has appeared in a previous moved row, if one exists. Do not overlap blocks. If there is no such previous block in that row, keep the horizontal alignment with the main data row.\n5. Repeat steps 3 and 4 for all nonzero entries above the main data row.\n6. After all blocks have been placed, set all other entries in the grid (not just above the main data row, and not holding the copied blocks) back to zero.\n7. Leave the main data row unchanged.", "test_input": [[9, 5, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 1, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7]]", "expected_output": [[9, 5, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 3, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 9, 5, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 1, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 3, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7]]}, "5b37cb25": {"instruction": "1. Identify the \"inner rectangle\" of the grid, which is the region excluding the outermost border of width 1 cell (i.e., exclude the first and last rows and columns).\n2. In this inner rectangle, locate the leftmost vertical region/column where the value transitions from the horizontal \"background\" value (here, 2) to another value (here, 3). This forms a vertical border.\n3. In each row of the inner rectangle, find the first entry to the right of this border with a different value (here, the first 1 after the 3-blocks).\n4. For each row, replace that first 1 (directly to the right of the left '3' border) with the value of the border (3).\n5. If, in steps moving rightward from the border, you find further consecutive cells containing the same value (here, the additional 1s adjacent), continue replacing them with the border value, up to a maximum of three adjacent replacements, unless interrupted by another value or the end of the segment.\n6. Repeat this process for every \"inner box\" that is analogous to the patterns identified in the training grids, matching the shifting and width of replaced regions based on interference from other structures (like ones, threes, etc.).\n7. Examine the bottom section of the grid, where, in the input, a rectangle of 3s replaces the original 1s. In that segment, follow the same procedure: for each row, at the first continuous 1-region after the 3-border, replace the first one with a 3, and if there are up to two more consecutive 1s, replace those as well.\n8. Ensure the top and bottom borders (first/last row and first/last column) remain unchanged.", "test_input": [[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 3, 3, 3, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0]], "predicted_output": "[[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],\n [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0]]", "expected_output": [[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 2, 2, 2, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 2, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 6, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 3, 3, 3, 6], [8, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 8, 8, 8, 1, 1, 1, 6, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 8, 1, 1, 1, 6, 6, 6, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 6, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 3, 3, 3, 6], [8, 3, 3, 8, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 1, 3, 3, 3, 6], [8, 3, 8, 8, 8, 1, 1, 1, 1, 1, 1, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 8, 1, 1, 1, 1, 1, 1, 6, 6, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0]]}, "5b526a93": {"instruction": "1. Identify each horizontal band of rows that contains repeated \"letter\" patterns made up of 1s (surrounded by zeros/empty rows). Each such band typically consists of 3 consecutive rows forming a shape.\n2. For each of these \"letter bands,\" find every group (cluster) of three columns, possibly separated by zeros, that contains these \"letter\" patterns (for example, patterns resembling the digit \"8\" using 1s).\n3. For every group of \"letter\" patterns except the first one in each band, replace all 1s in every subsequent group (not the very first group) within the band with 8s. Leave the first group of each band unchanged.\n4. All other grid values (0s and untouched 1s outside the replaced groups) remain unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 1, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "5ecac7f7": {"instruction": "1. Identify the central 5x5 block of the input grid, by centering a 5x5 square horizontally and vertically within the original grid.\n2. For each cell in this 5x5 block, replace its value with the value from the corresponding location in the input grid, but using the following process:\n  a. Associate the 5x5 block of the output with the center of the input grid; the position of the 5x5 should correspond to the center of the input grid.\n  b. Copy the value from the corresponding input cell if that cell is not part of a region where blocks of identical numbers (for example, a 2x2 or larger) cluster together.\n  c. If the input cell is part of such a region, identify the central value or distinct feature in that region, and use that value as the output for that cell if applicable. (For most grids, this just means copying the value--the step can be omitted if the clusters do not determine the output.)\n3. The resulting 5x5 grid becomes the output grid.", "test_input": [[4, 4, 9, 9, 7, 6, 8, 8, 7, 7, 7, 6, 2, 2, 7, 7, 7], [4, 7, 9, 9, 7, 6, 7, 8, 7, 7, 7, 6, 7, 2, 7, 9, 9], [4, 4, 7, 7, 2, 6, 8, 8, 7, 9, 9, 6, 2, 2, 5, 7, 9], [7, 4, 7, 7, 2, 6, 8, 7, 2, 7, 9, 6, 7, 2, 7, 9, 9], [4, 4, 7, 7, 2, 6, 8, 8, 7, 9, 9, 6, 2, 2, 7, 7, 7]], "predicted_output": "[[9, 7, 6, 8, 8],\n [9, 7, 6, 7, 8],\n [7, 2, 6, 8, 8],\n [7, 2, 6, 8, 7],\n [7, 2, 6, 8, 8]]", "expected_output": [[4, 4, 7, 7, 7], [4, 7, 7, 9, 9], [4, 4, 7, 7, 9], [7, 4, 2, 9, 9], [4, 4, 7, 7, 7]]}, "5ffb2104": {"instruction": "1. For each row in the input grid, shift all nonzero elements as far to the right as possible, maintaining their relative vertical order. This means that each row's nonzero elements will be moved towards the rightmost columns, filling those columns from right to left in the same row order.\n2. Fill any emptied cells on the left of each row with zeros, keeping the row lengths constant.", "test_input": [[0, 0, 0, 8, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [2, 0, 3, 3, 3, 0, 0, 0, 0, 0], [2, 0, 0, 0, 4, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 8, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 8, 2, 0],\n [0, 0, 0, 0, 0, 0, 0, 2, 2, 0],\n [0, 0, 0, 0, 0, 2, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 2, 4, 4, 4, 0],\n [0, 0, 0, 0, 0, 0, 0, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 6, 0],\n [0, 0, 0, 0, 0, 0, 0, 8, 6, 0],\n [0, 0, 0, 0, 0, 0, 0, 5, 5, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 8, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 0, 2, 3, 3, 3], [0, 0, 0, 0, 0, 0, 2, 4, 0, 4], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 8, 6], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8]]}, "60a26a3e": {"instruction": "1. For each row in the grid, locate sequences where there are two nonzero cells with the value 2, with only zeros between them (no other 2s in between in that sequence).\n2. For each such pair of 2s, fill all cells strictly between them in that row with the value 1.\n3. For each column in the grid, locate sequences where there are two nonzero cells with the value 2, with only zeros between them (no other 2s in between in that sequence).\n4. For each such pair of 2s, fill all cells strictly between them in that column with the value 1.\n5. Leave all other cells unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 2, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 1, 2, 0, 0, 2, 0, 0, 0, 0],\n [0, 2, 1, 2, 0, 0, 0, 0, 0, 2, 1, 2, 0, 0, 0],\n [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0], [0, 2, 0, 2, 1, 1, 1, 1, 1, 2, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "60b61512": {"instruction": "1. For each connected cluster of nonzero cells containing the value 4, identify the positions in the cluster where a 4 is immediately adjacent (horizontally or vertically) to at least one zero cell both above or below, or both left or right. These are the \"border inner corners\" where the 4 sits just inside an open space.\n2. In each such cluster, change these identified 4s to 7s if they have another 4 neighbor horizontally or vertically (not diagonally). In other words, for each 4 that is adjacent to at least one zero and at least one 4 (not counting diagonals) in its cluster, change that 4 to a 7.\n3. All other values remain unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 4, 0, 0, 0, 0],\n [0, 0, 7, 7, 0, 0, 0, 0, 0],\n [0, 0, 4, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 4, 0, 0, 0],\n [0, 0, 0, 0, 0, 7, 7, 7, 0],\n [0, 0, 0, 0, 0, 0, 4, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 4, 0, 0, 0, 0], [0, 0, 4, 4, 7, 0, 0, 0, 0], [0, 0, 4, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 7, 7, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 7, 4, 7, 0]]}, "60c09cac": {"instruction": "1. For each cell in the input grid, create a 2x2 block in the output grid, where the value of each cell in the block matches the value of the original cell.\n2. Place these 2x2 blocks in the output grid such that the relative positions of the original cells are preserved, but both the row and column positions are doubled. For example, the cell at position (i, j) in the input grid covers positions (2i, 2j), (2i, 2j+1), (2i+1, 2j), and (2i+1, 2j+1) in the output grid.\n3. Initialize all positions in the output grid with zero before filling in the 2x2 blocks.", "test_input": [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 6, 6, 6, 0], [0, 0, 1, 6, 0], [0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],\n [0, 0, 6, 6, 6, 6, 6, 6, 0, 0],\n [0, 0, 6, 6, 6, 6, 6, 6, 0, 0],\n [0, 0, 0, 0, 1, 1, 6, 6, 0, 0],\n [0, 0, 0, 0, 1, 1, 6, 6, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 1, 1, 6, 6, 0, 0], [0, 0, 0, 0, 1, 1, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "60d73be6": {"instruction": "1. Identify the row that consists entirely of the repeated non-background value (here, 4). This row serves as the axis of reflection (\"middle row\").\n2. For each row above the middle row, copy its non-background values (i.e., values not equal to 7) into the corresponding row below the middle row, at the same column indices and the same horizontal distance from the middle row as their original row is above it. \n   - For example, if a cell at (row, col) with value v is k rows above the middle row, set cell (middle row + k, col) to v.\n3. For each row below the middle row, copy its non-background values into the row above the middle row at the symmetric position, mirroring as described above.\n4. The middle row remains unchanged.", "test_input": [[7, 7, 7, 9, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 9, 7, 0, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 0, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 7, 7, 7, 7, 5, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 9, 7, 8, 3, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [6, 7, 7, 2, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [7, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "predicted_output": "[[7, 7, 7, 9, 7, 0, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 9, 7, 8, 3, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [8, 7, 7, 7, 7, 5, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [6, 7, 7, 2, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 9, 7, 0, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 0, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [7, 7, 0, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [7, 7, 7, 9, 7, 0, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [6, 7, 7, 2, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],\n [8, 7, 7, 7, 7, 5, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]", "expected_output": [[7, 7, 7, 9, 7, 7, 4, 7, 7, 9, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 9, 7, 0, 4, 0, 7, 9, 7, 7, 7, 7, 7, 7, 7], [6, 7, 0, 7, 7, 7, 4, 7, 7, 7, 0, 7, 6, 7, 7, 7, 7], [8, 7, 7, 7, 7, 5, 4, 5, 7, 7, 7, 7, 8, 7, 7, 7, 7], [7, 9, 7, 8, 3, 7, 4, 7, 3, 8, 7, 9, 7, 7, 7, 7, 7], [6, 7, 7, 2, 7, 7, 4, 7, 7, 2, 7, 7, 6, 7, 7, 7, 7], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [6, 7, 7, 2, 7, 7, 4, 7, 7, 2, 7, 7, 6, 7, 7, 7, 7], [7, 9, 7, 8, 3, 7, 4, 7, 3, 8, 7, 9, 7, 7, 7, 7, 7], [8, 7, 7, 7, 7, 5, 4, 5, 7, 7, 7, 7, 8, 7, 7, 7, 7], [6, 7, 0, 7, 7, 7, 4, 7, 7, 7, 0, 7, 6, 7, 7, 7, 7]]}, "6150a2bd": {"instruction": "1. Rotate the input grid 90 degrees clockwise.\n2. Reverse the order of the rows in the resulting grid (i.e., flip the grid vertically).", "test_input": [[6, 3, 5], [6, 8, 0], [4, 0, 0]], "predicted_output": "[[4, 6, 6],\n [0, 8, 3],\n [0, 0, 5]]", "expected_output": [[0, 0, 4], [0, 8, 6], [5, 3, 6]]}, "6165ea8f": {"instruction": "1. Identify all distinct \"blocks\" in the input grid. A \"block\" is a contiguous region of nonzero cells with the same value; blocks do not touch each other.\n2. For each block, determine its main color value and the smallest bounding rectangle that fully contains the block.\n3. Group all blocks of the same color together. There should be one group for each color present in the input grid (excluding zeros).\n4. Within each color group, find the largest block. For that group, extract this block, and replicate it horizontally so that there are two copies side by side with one column of zeros (as a separator) between them.\n5. For each color group, organize as follows:\n   - The first two rows: Place the two replicated blocks from step 4 side by side with a column of zeros between; pad each row with zeros as needed so all such constructed rows are the same length.\n   - The next row: Create a row of zeros the same width as those in the previous step (this is a horizontal separator between sections).\n   - The next two rows: Take the second-largest (or next appropriate) block of the same color (if present), repeat as above for step 4, and so on if there are more blocks in the color group.\n   - If there are not enough blocks for two rows per group, fill those missing rows with zeros.\n6. Repeat step 5 for each color group, vertically stacking the resulting blocks (with a row of zeros between each color section). This builds color-aligned square sections down the output grid: two rows of patterns, a separating zero row, and so on.\n7. For each color group, if that group contains only one structure/block, replicate that block horizontally for two columns with zero separator as above.\n8. In all blocks, replace the original color value in the right copy with a new value according to the following mapping observed in examples:\n   - For the original color in each right copy: \n     - 1 \u2192 2\n     - 3 \u2192 5\n     - 4 \u2192 2\n     - 6 \u2192 5\n     - 7 \u2192 2\n     - 8 \u2192 2\n     - 9 \u2192 5\n     Note: for colors not specified, use 5 for the right copy or refer to analogous mappings from examples.\n9. Make sure the final output grid is trimmed: remove any fully zero rows and/or columns at the borders so that only the described colored blocks and separators remain.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 3, 3, 3, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 3, 0, 0, 9], [0, 0, 0, 4, 0, 0, 4, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 3, 0, 0, 6], [0, 0, 0, 4, 0, 0, 4, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 0, 0, 6, 0, 6, 6, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 8, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 7, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2],\n [1, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [3, 3, 3, 0, 3, 3, 3, 0, 5, 5, 5, 0, 5, 5, 5],\n [0, 3, 0, 0, 0, 3, 0, 0, 5, 0, 0, 0, 0, 5, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2],\n [4, 0, 0, 4, 0, 4, 0, 0, 4, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [6, 6, 6, 6, 0, 6, 6, 6, 6, 0, 5, 5, 5, 5, 0, 5, 5, 5, 5],\n [0, 6, 0, 0, 0, 6, 0, 0, 6, 0, 5, 0, 0, 0, 0, 5, 0, 0, 5],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [7, 7, 7, 7, 7, 0, 7, 7, 7, 7, 7, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2],\n [7, 0, 0, 0, 7, 0, 7, 0, 0, 0, 7, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [8, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2],\n [8, 0, 8, 0, 0, 0, 8, 0, 8, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 9, 9, 9, 9, 9, 0, 5, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5, 5],\n [9, 0, 0, 0, 0, 0, 9, 0, 9, 0, 0, 0, 0, 0, 9, 0, 5, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 5]]", "expected_output": [[0, 0, 0, 1, 1, 0, 3, 3, 0, 4, 4, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0, 6, 6], [0, 0, 0, 1, 1, 0, 3, 3, 0, 4, 4, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5], [1, 1, 0, 0, 0, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 0, 2, 2, 0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5], [3, 3, 0, 2, 2, 0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 5, 5], [4, 4, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 2, 2], [7, 7, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 5, 5], [8, 8, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 9, 0, 2, 2, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5], [9, 9, 0, 2, 2, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 0, 0], [6, 6, 0, 5, 5, 0, 5, 5, 0, 5, 5, 0, 2, 2, 0, 5, 5, 0, 5, 5, 0, 0, 0]]}, "623ea044": {"instruction": "1. Locate the single nonzero cell in the input grid (let's call its value C and its position (r, c)).\n2. For each cell in the grid, compute the Manhattan distance d from that cell to (r, c).\n3. For every cell where (r + c + d) is divisible by 2 (i.e., parity matches the original nonzero cell), and d <= min(r, c, rows-1-r, cols-1-c), place the value C in that cell. Otherwise, leave it as 0.\n4. The result is a diamond-shaped pattern centered at (r, c), filling the grid in a specific diamond checkerboard pattern with value C.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "626c0bcc": {"instruction": "1. Identify all contiguous regions (blobs) of 8s that are connected orthogonally (not diagonally). Each blob will be assigned a unique new color according to its position:\n    - The blob furthest to the left and top is mapped to color 2 or 1, depending on the layout. Generally, the codebook (from above examples) is: \n      * Top-left vertical blob = 2,\n      * Vertical blobs farther right = 4,\n      * Lower blobs with horizontal orientation = 1,\n      * Middle vertical blobs surrounded by blobs = 3,\n      * Blobs surrounded on both sides or bins = 2.\n2. Analyze the positions of the blobs:\n    - Assign color 2 to the leftmost vertical blob(s) in the upper rows.\n    - Assign color 4 to the rightmost vertical blob(s) in the upper rows.\n    - Assign color 1 to horizontally extended blob(s) in the central rows.\n    - Assign color 3 to any vertical blob(s) beneath or to the lower side of the grid, where not adjacent to the sides.\n3. Replace all 8s in each blob with their assigned color, keeping all 0s as is.", "test_input": [[0, 8, 8, 0, 8, 8, 0], [8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 0, 8, 0, 0], [0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 2, 2, 0, 4, 4, 0],\n [2, 2, 2, 3, 4, 4, 0],\n [0, 2, 2, 0, 4, 0, 0],\n [0, 0, 3, 3, 4, 0, 0],\n [0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 2, 4, 0, 1, 1, 0], [2, 2, 4, 4, 1, 1, 0], [0, 3, 3, 0, 2, 0, 0], [0, 0, 3, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, "62ab2642": {"instruction": "1. Identify contiguous horizontal runs (two or more) of the color 5 in each row. For each such run that starts with a 0 and ends with a 0 (or grid border), change the first and second elements of the run from [0, 5, 5, ...] to [0, 5, 7, 7, ...] (if run is at least length 3), replacing the second and third elements of the run with 7.\n2. For every vertical segment in the grid where there is a column of contiguous 5s bordered on the right by 0s or grid border, change all 0s in columns immediately to the right of this segment, below the row of the horizontal run transformed in step 1 (if present), to 8. Continue replacing downward until another non-0 cell or the bottom of the grid is reached.\n3. Repeat for all such runs and segments in the grid.", "test_input": [[0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0], [0, 5, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0], [5, 5, 5, 0, 0, 5, 0, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 0, 5, 0, 5, 5, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0]], "predicted_output": "[[0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0],\n [0, 5, 0, 0, 0, 7, 7, 5, 0, 5, 7, 7],\n [5, 5, 5, 0, 0, 5, 0, 5, 5, 5, 0, 0],\n [0, 0, 7, 7, 5, 5, 0, 5, 0, 5, 5, 0],\n [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0]]", "expected_output": [[7, 5, 8, 8, 8, 8, 8, 5, 0, 0, 5, 0], [7, 5, 8, 8, 8, 5, 5, 5, 0, 5, 5, 0], [5, 5, 5, 8, 8, 5, 0, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 0, 5, 0, 5, 5, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0]]}, "62b74c02": {"instruction": "1. For each row in the input grid, determine the length L of the initial nonzero sequence starting from the left (ignore trailing zeros).\n2. Identify the color values present in the first L columns of each row; these constitute the \"core pattern\" of the row.\n3. For each row, insert (L-2) additional columns between column 3 and column (L+1). Fill these columns, and all columns to the right of column 3 up to column (L+1), with the color from column 0 of that row. This will extend the row's length to 2*L - 1.\n4. In column (2*L-2) of each row, fill with the value present in column 1 of the original row (the second element of the pattern).\n5. In column (2*L-1) of each row, fill with the value present in column 2 of the original row (the third element of the pattern; if L > 3).\n6. Leave all other filled values the same as in their respective positions in the core pattern, and ensure there are no trailing zeros; the row should now have length 2*L - 1.", "test_input": [[3, 8, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 3, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[3, 8, 8, 3, 3, 3, 8, 8],\n [2, 1, 1, 2, 2, 1, 1],\n [1, 3, 3, 1, 1, 3, 3],\n [2, 1, 1, 2, 2, 1, 1]]", "expected_output": [[3, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 3], [2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2], [1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1], [2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2]]}, "62c24649": {"instruction": "1. Take the input grid and create a copy of it.\n2. Horizontally reflect (mirror) the input grid to create its horizontal mirror image.\n3. Concatenate the original input grid and its horizontal mirror image side-by-side to form a new grid that is twice as wide.\n4. Vertically reflect (mirror) the result from step 3 to create its vertical mirror image.\n5. Concatenate the grid from step 3 and its vertical mirror image top-to-bottom to form the final grid, which is twice as high and twice as wide as the original.", "test_input": [[1, 1, 0], [0, 3, 2], [3, 3, 0]], "predicted_output": "[[1, 1, 0, 0, 1, 1],\n [0, 3, 2, 2, 3, 0],\n [3, 3, 0, 0, 3, 3],\n [3, 3, 0, 0, 3, 3],\n [0, 3, 2, 2, 3, 0],\n [1, 1, 0, 0, 1, 1]]", "expected_output": [[1, 1, 0, 0, 1, 1], [0, 3, 2, 2, 3, 0], [3, 3, 0, 0, 3, 3], [3, 3, 0, 0, 3, 3], [0, 3, 2, 2, 3, 0], [1, 1, 0, 0, 1, 1]]}, "6350f1f4": {"instruction": "1. Identify all non-background (non-zero) regions in the grid that are separated by background rows or columns (i.e., rows or columns where all values are 0).\n2. For each such region, replace every non-background, non-separator color with the dominant color in that local region (the color that appears most often, excluding background and any separator values like 0 or 5 if 5 is used as a separator in that subgrid).\n3. Maintain all background rows and columns (those fully consisting of 0s) as they are in their positions.\n4. Reconstruct the grid with each previously identified region now replaced by its uniform dominant color (excluding background and separators), interleaved with the untouched background rows or columns.", "test_input": [[1, 1, 1, 2, 0, 1, 1, 1, 2, 0, 1, 1, 1, 2, 0, 2, 5, 2, 2], [1, 2, 2, 1, 0, 1, 2, 2, 1, 0, 1, 2, 2, 1, 0, 5, 5, 2, 2], [2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 5, 2, 2, 2], [1, 2, 1, 1, 0, 1, 2, 1, 1, 0, 1, 2, 1, 1, 0, 5, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [1, 1, 1, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 5, 5, 5, 1, 1, 2], [1, 2, 2, 1, 5, 5, 5, 2, 2, 0, 2, 2, 5, 5, 0, 1, 2, 2, 1], [2, 1, 1, 5, 5, 5, 2, 2, 2, 0, 2, 5, 5, 2, 0, 2, 5, 5, 1], [1, 2, 5, 5, 0, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 5, 5], [0, 0, 5, 0, 0, 0, 0, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 5, 5], [2, 2, 5, 5, 0, 1, 1, 5, 5, 5, 1, 5, 1, 2, 0, 1, 1, 5, 2], [5, 5, 5, 5, 0, 1, 2, 2, 1, 5, 5, 5, 5, 1, 0, 1, 5, 5, 1], [2, 2, 2, 2, 0, 2, 1, 1, 1, 5, 5, 1, 5, 5, 0, 5, 5, 1, 1], [2, 2, 2, 2, 0, 1, 2, 1, 1, 5, 1, 5, 5, 5, 5, 5, 2, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0, 0, 0, 0], [1, 1, 1, 2, 0, 2, 2, 2, 2, 5, 1, 1, 1, 5, 5, 5, 1, 1, 2], [1, 2, 2, 1, 0, 2, 2, 2, 5, 0, 5, 2, 5, 5, 5, 5, 2, 2, 1], [2, 1, 1, 1, 0, 2, 2, 5, 2, 0, 5, 5, 1, 1, 5, 2, 1, 1, 1], [1, 2, 1, 1, 0, 2, 2, 2, 2, 0, 1, 5, 5, 5, 5, 1, 2, 1, 1]], "predicted_output": "[[1, 1, 1, 2, 0, 1, 1, 1, 2, 0, 1, 1, 1, 2, 0, 2, 2, 2, 2],\n [1, 2, 2, 1, 0, 1, 2, 2, 1, 0, 1, 2, 2, 1, 0, 2, 2, 2, 2],\n [2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 2, 2, 2],\n [1, 2, 1, 1, 0, 1, 2, 1, 1, 0, 1, 2, 1, 1, 0, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0],\n [2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 5, 5, 5, 2, 2, 2],\n [2, 2, 2, 2, 5, 5, 5, 2, 2, 0, 2, 2, 5, 5, 0, 2, 2, 2, 2],\n [2, 2, 2, 5, 5, 5, 2, 2, 2, 0, 2, 5, 5, 2, 0, 2, 5, 5, 2],\n [2, 2, 5, 5, 0, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 2, 5, 5],\n [0, 0, 5, 0, 0, 0, 0, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 5, 5],\n [2, 2, 5, 5, 0, 1, 1, 5, 5, 5, 1, 5, 1, 2, 0, 1, 1, 5, 2],\n [5, 5, 5, 5, 0, 1, 2, 2, 1, 5, 5, 5, 5, 1, 0, 1, 5, 5, 1],\n [2, 2, 2, 2, 0, 2, 1, 1, 1, 5, 5, 1, 5, 5, 0, 5, 5, 1, 1],\n [2, 2, 2, 2, 0, 1, 2, 1, 1, 5, 1, 5, 5, 5, 5, 5, 2, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0, 0, 0, 0],\n [2, 2, 2, 2, 0, 2, 2, 2, 2, 5, 1, 1, 1, 5, 5, 5, 2, 2, 2],\n [2, 2, 2, 2, 0, 2, 2, 2, 5, 0, 5, 2, 5, 5, 5, 5, 2, 2, 2],\n [2, 2, 2, 2, 0, 2, 2, 5, 2, 0, 5, 5, 1, 1, 5, 2, 2, 2, 2],\n [2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 1, 5, 5, 5, 5, 2, 2, 2, 2]]", "expected_output": [[1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 2], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 2, 2, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 2, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 2, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 2, 0, 1, 1, 1, 2, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 2, 2, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 2, 1, 1, 1, 0, 2, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 2, 1, 1, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 2, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 2, 2, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [2, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 2, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 2, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 2, 2, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 2, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1]]}, "63613498": {"instruction": "1. Identify all distinct horizontal or vertical groups of identical nonzero numbers in the grid. For each such group, check whether it is immediately above a horizontal or vertical group of 5s (i.e., if there is an otherwise similar group in the same columns/rows, but in a lower position, made of 5s).\n2. For any such group found (i.e., a horizontal or vertical group of identical nonzero numbers that is not 5 and is not at the same level as the group of 5s), replace every cell in that group with 5.\n3. Leave all other cells in the grid unchanged.", "test_input": [[0, 0, 0, 5, 0, 0, 0, 6, 0, 0], [2, 2, 2, 5, 0, 0, 0, 6, 6, 0], [0, 0, 2, 5, 0, 0, 0, 6, 0, 0], [5, 5, 5, 5, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 4, 0], [8, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 7, 7, 7, 0, 4, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 5, 0, 0, 0, 6, 0, 0],\n [5, 5, 5, 5, 0, 0, 0, 6, 6, 0],\n [0, 0, 5, 5, 0, 0, 0, 6, 0, 0],\n [5, 5, 5, 5, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 3, 3, 0, 0, 0],\n [8, 8, 8, 0, 0, 0, 0, 0, 4, 0],\n [8, 0, 0, 0, 0, 0, 0, 0, 4, 0],\n [0, 0, 0, 0, 7, 7, 7, 0, 4, 0],\n [0, 0, 0, 0, 0, 0, 7, 0, 0, 0]]", "expected_output": [[0, 0, 0, 5, 0, 0, 0, 6, 0, 0], [2, 2, 2, 5, 0, 0, 0, 6, 6, 0], [0, 0, 2, 5, 0, 0, 0, 6, 0, 0], [5, 5, 5, 5, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 4, 0], [8, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 5, 5, 5, 0, 4, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0]]}, "639f5a19": {"instruction": "1. Identify every contiguous rectangular block of the number 8, surrounded by 0s or grid borders.\n2. For each group of contiguous 8s, replace them with a pattern according to their row position within the group:\n    a. For the top two rows of the group, replace 8 with 6 on the left half and with 1 on the right half.\n    b. For the next three rows (usually middle/sandwich rows), replace 8 with 4 in the center, flanked by 6 (or 2) on the left and 1 (or 3) on the right.\n    c. For the next four rows (lower rows), replace 8 with 2 on the left half and 3 on the right half.\n    d. If the group is larger, use only the pattern that fits its size (observing symmetry in the pattern splitting).\n3. Keep all non-8 cells (0s or otherwise) unchanged.\n4. Repeat this logic for every separated block or sub-block of 8s in the grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 0],\n [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0],\n [0, 0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 4, 4, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 4, 4, 1, 1, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0], [0, 0, 0, 6, 6, 4, 4, 1, 1, 0, 0, 0, 6, 6, 6, 6, 6, 1, 1, 1, 1, 1, 0], [0, 0, 0, 2, 2, 4, 4, 3, 3, 0, 0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 1, 1, 0], [0, 0, 0, 2, 2, 4, 4, 3, 3, 0, 0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 1, 1, 0], [0, 0, 0, 2, 2, 4, 4, 3, 3, 0, 0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 1, 1, 0], [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 1, 1, 0], [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 6, 6, 4, 4, 4, 4, 4, 4, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 2, 2, 4, 4, 4, 4, 4, 4, 3, 3, 0], [0, 0, 0, 6, 6, 6, 1, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 0], [0, 0, 0, 6, 6, 4, 4, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 0], [0, 0, 0, 2, 2, 4, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "642248e4": {"instruction": "1. For each row, scan from left to right.\n2. Whenever a cell contains the value 1:\n    a. If the columns to the immediate left and/or right of the 1 (within bounds) are not on the edge of the grid and do not already contain the edge value (i.e., the nonzero color present at the far left/right), then:\n        i. Replace the immediate left cell (if not the edge) with the color present at the leftmost column in that row.\n        ii. Replace the immediate right cell (if not the edge) with the color present at the rightmost column in that row.\n3. Do not overwrite any existing nonzero, non-background values (including the 1s and existing border/edge values).\n4. All other cells remain unchanged.", "test_input": [[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8], [2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]], "predicted_output": "[[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 8, 8],\n [2, 0, 1, 2, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 8, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 2, 1, 0, 8, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 8, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8],\n [2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 8, 8],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]]", "expected_output": [[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8], [2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]]}, "642d658d": {"instruction": "1. Examine the input grid and locate the distinct 3x3 square block that contains the numbers 3, 4, and 3 aligned horizontally within a row, with the number 4 in the center and two 3s adjacent (forming [3, 4, 3]).\n2. Once the [3, 4, 3] pattern is found, identify the color/value of the cells surrounding this pattern, focusing specifically on the background color/value of the main field in which the [3, 4, 3] is embedded. For example, in your input test, this surrounding value is 9.\n3. Return a single-cell grid (1x1) containing the value that forms the main background of the grid where the [3, 4, 3] motif is placed (here, 9).", "test_input": [[0, 0, 9, 9, 0, 9, 0, 9, 0, 6, 0, 9, 0, 0, 9, 9, 0, 9, 0, 0, 9, 0], [0, 0, 9, 9, 9, 9, 3, 9, 9, 9, 0, 9, 0, 0, 9, 9, 0, 6, 0, 9, 9, 0], [9, 9, 2, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9], [9, 2, 4, 2, 9, 9, 9, 0, 9, 9, 0, 9, 0, 3, 9, 9, 9, 1, 9, 9, 2, 9], [9, 9, 2, 9, 9, 9, 6, 9, 9, 9, 6, 9, 9, 9, 2, 0, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9, 9, 0, 9, 9, 0, 0, 9, 9, 9, 9, 0, 9, 9, 9, 9, 9, 9, 9], [0, 0, 9, 9, 9, 9, 0, 9, 9, 9, 0, 9, 3, 0, 9, 9, 0, 9, 0, 9, 9, 0], [9, 9, 9, 0, 9, 9, 9, 3, 9, 9, 9, 9, 0, 9, 9, 9, 9, 0, 9, 9, 9, 9], [6, 9, 9, 0, 9, 9, 3, 4, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 0, 9, 9, 9, 3, 9, 3, 9, 9, 9, 9, 9, 9, 6, 9, 9, 0, 0, 3], [0, 0, 0, 1, 9, 9, 0, 9, 9, 9, 0, 9, 0, 0, 9, 6, 4, 6, 0, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 9, 0, 2, 9, 9, 9, 6, 9, 9, 0, 9, 1], [0, 0, 9, 9, 9, 9, 0, 9, 9, 9, 0, 9, 0, 0, 9, 9, 0, 9, 0, 9, 0, 0], [0, 0, 9, 2, 9, 9, 3, 9, 0, 6, 0, 9, 0, 0, 9, 9, 0, 9, 0, 9, 9, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9, 9, 9], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 9, 0, 9, 9, 9, 2, 9], [0, 6, 3, 9, 9, 9, 0, 9, 9, 0, 0, 9, 0, 3, 9, 9, 0, 2, 0, 0, 9, 0], [9, 9, 9, 9, 9, 9, 0, 3, 9, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 9, 9, 9, 9, 0, 9, 9, 2, 0, 9, 0, 0, 9, 9, 0, 9, 0, 9, 9, 0], [9, 9, 9, 9, 0, 9, 9, 9, 9, 9, 9, 6, 0, 9, 9, 9, 9, 9, 9, 9, 6, 9], [9, 9, 9, 9, 1, 9, 9, 9, 9, 9, 0, 9, 9, 9, 9, 3, 9, 9, 9, 9, 9, 9], [0, 0, 0, 1, 4, 1, 0, 9, 9, 0, 0, 9, 0, 0, 0, 9, 0, 9, 2, 9, 0, 0], [0, 0, 9, 9, 1, 9, 0, 9, 9, 9, 0, 9, 0, 0, 9, 9, 0, 9, 0, 9, 9, 0], [3, 9, 9, 9, 9, 0, 9, 9, 0, 9, 9, 9, 2, 9, 0, 9, 9, 9, 9, 0, 0, 9], [9, 9, 9, 9, 9, 9, 6, 9, 9, 9, 9, 2, 4, 2, 9, 9, 0, 9, 9, 9, 9, 9], [0, 0, 9, 9, 9, 9, 0, 0, 9, 1, 0, 9, 2, 0, 9, 9, 0, 9, 6, 9, 9, 0], [9, 9, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 9, 9]], "predicted_output": "[[9]]", "expected_output": [[2]]}, "6430c8c4": {"instruction": "1. Divide the input grid into three segments: the first 4 rows (\"Shape A\"), the 5th row (a separator), and the last 4 rows (\"Shape B\") below the separator.  \n2. For each cell in \"Shape A\" (4x4 grid):  \n    a. For each position (i, j) in \"Shape A\", if the corresponding cell in \"Shape B\" at (i, j) contains the value 2, then set the output cell at (i, j) to 3.  \n    b. Otherwise, set the output cell at (i, j) to 0.  \n3. The output grid is therefore a 4x4 grid where each cell is 3 if \"Shape B\" at that cell is 2, and 0 otherwise.", "test_input": [[7, 7, 7, 7], [0, 7, 7, 7], [7, 0, 0, 0], [7, 0, 7, 0], [4, 4, 4, 4], [0, 2, 2, 2], [0, 0, 0, 0], [2, 0, 2, 2], [0, 2, 0, 0]], "predicted_output": "[[0, 3, 0, 0],\n [0, 0, 3, 3],\n [0, 3, 0, 0],\n [0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0], [3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 0, 3]]}, "6455b5f5": {"instruction": "1. Identify the central vertical column composed entirely of the number 2, and any columns composed entirely of 2's that are adjacent to it (above, below, or alongside) that extend without interruption (no 0's or other numbers breaking the sequence). For these columns, do not make any changes.\n2. For every row above and below these solid columns of 2's, locate the regions to the right of these columns. If such regions exist, fill the next set of contiguous empty (0) cells to the right of the 2's with the value 1, continuing until you reach another non-zero cell or the edge of the grid. This region forms a vertical rectangle of 1's of the same height as the region.\n3. For every row above and below the solid 2's columns, locate the regions to the left of these columns/rows. If such regions exist, fill the next set of contiguous empty (0) cells to the left of the 2's with the value 8, continuing until you reach another non-zero cell or the edge of the grid. This region forms a vertical rectangle of 8's of the same height as the region.\n4. In any row where a horizontal sequence of 2's terminates and is not adjacent to the grid border, fill cells immediately to the left of this sequence with 8, and to the right with 1, as much as possible, bounded by 0's and edge of grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 1, 1],\n [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 1, 1],\n [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 1, 1]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0], [8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0]]}, "64a7c07e": {"instruction": "1. For each nonzero contiguous shape (group of adjacent cells with the same nonzero value), find its minimal bounding rectangle (subgrid).\n2. For each such subgrid, move it horizontally so that its leftmost column containing a nonzero value is now aligned with the column index that is as far to the right as possible, while maintaining its row position. This is done by finding the rightmost available set of columns to place it, so that within the same row span, all non-background values of the shape are \"shifted\" to the rightmost possible position.\n3. Place the shifted subgrid in the new position, keeping its cell pattern and shape unchanged, and replace the previously occupied cells with the background value (typically zero).\n4. Repeat for all such shapes independently within the grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "652646ff": {"instruction": "1. Identify all visually distinct \"regions\" or \"blocks\" within the input grid that share the same structural layout and coloring, as in the solved examples. The blocks appear as nested shapes composed of the same background color (here, 1), each containing secondary colors, and are stacked vertically (each block getting repeated with different inner values).\n2. For each region/block, locate the \"core\" pattern within the input grid. For this task, these are specifically formed, compact clusters of non-background (not-1) cells, such as the embedded rectangles constructed of 8s, 7s, 4s, 3s, or 0s, typically bordered by 1s.\n3. For every distinct region/block, extract its minimal bounding rectangle\u2014i.e., the smallest subgrid that contains all its non-background cells with the surrounding context that forms a symmetric figure. \n4. Abstract and reformat each block by normalizing it into a smaller, canonical template following the structural rules observed in previous output grids: the outermost border is the background (here, 1); next comes a ring of the primary pattern color (e.g., 8, 7, 4, 3); possibly followed by a ring of a secondary color and so on, matching the layer structure and count for that block in the output examples.\n5. Reconstruct the output grid by stacking these normalized canonical blocks, one after the other, preserving their vertical order and internal layer structure, but discarding all original background areas that surrounded or separated the blocks in the input. Ensure only the compact, reduced patterns (with borders) are present in the output, without any excess padding.\n6. The final output should be a vertically stacked sequence of the condensed patterns (each about 6 columns wide), with only as much padding/background as needed for border symmetry. The output height is the sum of the canonical block heights.", "test_input": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 8, 8, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 8, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 8, 4, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 8, 7, 7, 8, 1, 1, 4, 1, 1, 1, 1], [1, 1, 1, 5, 1, 1, 3, 8, 8, 7, 1, 1, 1, 4, 1, 1, 1], [1, 1, 1, 1, 1, 3, 1, 1, 4, 1, 7, 1, 1, 4, 1, 1, 1], [1, 1, 1, 1, 3, 7, 1, 1, 1, 4, 7, 1, 4, 1, 1, 1, 1], [1, 1, 1, 1, 3, 1, 7, 1, 1, 3, 4, 4, 1, 1, 1, 1, 5], [1, 1, 1, 1, 1, 3, 1, 7, 3, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "predicted_output": "[[1, 1, 1, 1, 1, 1],\n [1, 8, 8, 8, 8, 1],\n [1, 8, 1, 1, 8, 1],\n [1, 8, 1, 1, 8, 1],\n [1, 8, 8, 8, 8, 1],\n [1, 1, 1, 1, 1, 1],\n\n [1, 7, 7, 7, 7, 1],\n [1, 7, 4, 4, 7, 1],\n [1, 7, 4, 4, 7, 1],\n [1, 7, 7, 7, 7, 1],\n\n [1, 3, 3, 3, 3, 1],\n [1, 3, 7, 7, 3, 1],\n [1, 3, 7, 7, 3, 1],\n [1, 3, 3, 3, 3, 1]]", "expected_output": [[1, 1, 8, 8, 1, 1], [1, 8, 1, 1, 8, 1], [8, 1, 1, 1, 1, 8], [8, 1, 1, 1, 1, 8], [1, 8, 1, 1, 8, 1], [1, 1, 8, 8, 1, 1], [1, 1, 4, 4, 1, 1], [1, 4, 1, 1, 4, 1], [4, 1, 1, 1, 1, 4], [4, 1, 1, 1, 1, 4], [1, 4, 1, 1, 4, 1], [1, 1, 4, 4, 1, 1], [1, 1, 3, 3, 1, 1], [1, 3, 1, 1, 3, 1], [3, 1, 1, 1, 1, 3], [3, 1, 1, 1, 1, 3], [1, 3, 1, 1, 3, 1], [1, 1, 3, 3, 1, 1], [1, 1, 7, 7, 1, 1], [1, 7, 1, 1, 7, 1], [7, 1, 1, 1, 1, 7], [7, 1, 1, 1, 1, 7], [1, 7, 1, 1, 7, 1], [1, 1, 7, 7, 1, 1]]}, "662c240a": {"instruction": "1. Divide the input grid into three contiguous blocks of three rows each, maintaining their original order.  \n2. Select only the **middle** block of three rows (i.e., the 4th, 5th, and 6th rows of the input grid).  \n3. Output these three rows as the output grid, in the same order as they appear in the input.", "test_input": [[5, 4, 4], [4, 5, 4], [4, 5, 4], [3, 3, 2], [3, 3, 2], [2, 2, 3], [1, 1, 1], [1, 8, 8], [1, 8, 8]], "predicted_output": "[[3, 3, 2],\n [3, 3, 2],\n [2, 2, 3]]", "expected_output": [[5, 4, 4], [4, 5, 4], [4, 5, 4]]}, "668eec9a": {"instruction": "1. Identify and extract all the unique non-background colors (distinct from the background, which is 7) present along the primary diagonal running from the lower left to the upper right of the grid (and their associated anti-diagonals at the lower part of the grid).\n2. For each found non-background color, starting from the first appearance at the lower left (bottom-most row/left-most column) and moving upwards/rightwards, collect all cells of that color that appear consecutively along their respective anti-diagonal.\n3. For each collected color (in the order encountered from the bottom left upward/rightward), create a new row in the output grid, where each row contains 3 entries, all set to that color.\n4. Stack the rows in the order found, from the bottom-most color to the top-most color.", "test_input": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 5, 7, 1, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 5, 4, 7, 7, 1, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 5, 7, 7, 4, 7, 7, 1, 7, 7, 7, 7, 7], [7, 7, 7, 5, 7, 7, 7, 7, 4, 7, 7, 1, 7, 7, 7, 7], [7, 7, 5, 7, 7, 7, 7, 7, 7, 4, 7, 7, 1, 7, 7, 7], [7, 5, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7]], "predicted_output": "[[3, 3, 3],\n [5, 5, 5],\n [4, 4, 4],\n [1, 1, 1]]", "expected_output": [[7, 7, 7], [5, 5, 5], [1, 1, 1], [4, 4, 4], [3, 3, 3]]}, "66ac4c3b": {"instruction": "1. For each row in the grid, identify contiguous groups of cells with color 1 (the \"1-blocks\").\n2. For each such group, look directly to the right of the rightmost cell of the \"1-block\". If the next cell is color 4, change that cell to color 2.\n3. After completing step 2 for all rows, for every \"1-block\" in a row, check if the 1-block has exactly three cells and is directly followed (on its right) by three consecutive color 4 cells. If so, change those three color 4 cells to color 2.\n4. The rest of the grid remains unchanged.", "test_input": [[3, 3, 3, 3, 3, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 1, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]], "predicted_output": "[[3, 3, 3, 3, 3, 4, 4, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 4, 4, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 4, 4, 4, 4, 4, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 4, 4, 4, 4, 4, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 4, 4, 1, 2, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3],\n [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]", "expected_output": [[3, 3, 3, 3, 3, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 1, 1, 1, 3, 3, 3, 3], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3], [3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3], [3, 3, 3, 3, 3, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 1, 1, 1, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 1, 3, 3, 3, 3, 3, 4, 1, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], [3, 3, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 1, 1, 1, 1, 1, 1, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3], [3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3], [3, 3, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 3, 3, 4, 1, 1, 1, 1, 1, 1, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 4, 4, 1, 3, 3, 3, 3, 3, 4, 1, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3]]}, "66e6c45b": {"instruction": "1. Identify the central 2x2 subgrid of the input grid (located at rows 1-2 and columns 1-2, ignoring the outer border).\n2. Copy the top row of the central 2x2 subgrid and place its first element at the top-left corner (position [0,0]) and its second element at the top-right corner (position [0,3]) of the output grid.\n3. Copy the bottom row of the central 2x2 subgrid and place its first element at the bottom-left corner (position [3,0]) and its second element at the bottom-right corner (position [3,3]) of the output grid.\n4. Set all other positions in the output grid to 0.", "test_input": [[0, 0, 0, 0], [0, 2, 3, 0], [0, 4, 9, 0], [0, 0, 0, 0]], "predicted_output": "[[2, 0, 0, 3],\n [0, 0, 0, 0],\n [0, 0, 0, 0],\n [4, 0, 0, 9]]", "expected_output": [[2, 0, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [4, 0, 0, 9]]}, "66f2d22f": {"instruction": "1. Divide the input grid into two equal-width halves by splitting it vertically through the center.\n2. For each half, scan for all contiguous regions of nonzero cells that are colored 3.\n3. For each region of 3s, count the number of 3s and determine the minimal bounding box (smallest rectangle containing all 3s).\n4. In each half, map the spatial arrangement of the 3s in the bounding box to a corresponding position in the output grid\u2014this means the output grid will be half the width of the input grid, and positioned such that the pattern fits within its bounds.\n5. Replace every cell in each mapped region (corresponding to the arrangement of 3s in the bounding box) with the value 5 in the output grid.\n6. Fill all other cells in the output grid with 0.", "test_input": [[3, 0, 3, 0, 0, 3, 3, 0, 0, 2, 2, 0, 2, 2], [3, 0, 0, 0, 3, 3, 0, 2, 0, 0, 0, 0, 2, 0], [0, 3, 0, 3, 0, 3, 0, 0, 2, 2, 2, 0, 2, 2], [0, 3, 0, 0, 3, 3, 3, 0, 2, 0, 0, 0, 2, 2]], "predicted_output": "[[5, 0, 5, 0, 0, 0, 0],\n [5, 0, 0, 0, 5, 0, 0],\n [0, 5, 0, 5, 0, 0, 0],\n [0, 5, 0, 0, 5, 5, 5]]", "expected_output": [[0, 5, 0, 0, 5, 0, 0], [0, 5, 5, 5, 0, 0, 5], [5, 0, 0, 0, 5, 0, 0], [5, 0, 5, 5, 0, 0, 0]]}, "67385a82": {"instruction": "1. For each position in the grid, check if the value is 3.\n2. If the value is 3 and it is part of a contiguous block of 3s directly connected (horizontally and/or vertically) to at least one other 3, replace that value with 8.  \n3. If the value is 3 but is not directly connected to any other 3 (i.e., it is isolated), leave it unchanged.  \n4. All other values remain unchanged.", "test_input": [[3, 0, 3, 0, 3], [3, 3, 3, 0, 0], [0, 0, 0, 0, 3], [0, 3, 3, 0, 0], [0, 3, 3, 0, 0]], "predicted_output": "[[8, 0, 8, 0, 3],\n [8, 8, 8, 0, 0],\n [0, 0, 0, 0, 3],\n [0, 8, 8, 0, 0],\n [0, 8, 8, 0, 0]]", "expected_output": [[8, 0, 8, 0, 3], [8, 8, 8, 0, 0], [0, 0, 0, 0, 3], [0, 8, 8, 0, 0], [0, 8, 8, 0, 0]]}, "673ef223": {"instruction": "1. For each row in the grid, scan for any nonzero (specifically, value 8) cell that is positioned to the right of a contiguous block of nonzero (specifically 2) cells along the left edge or top/bottom edge of the grid.\n2. For each such \"8\" found, replace all zero-valued cells in that row between the leftmost \"2\" and the \"8\" (exclusive) with \"8\". That is, fill all the cells in that horizontal region (left of the 8, right of the 2) with 8.\n3. Replace the \"8\" cell itself with \"4\" to mark the end of the filled segment in that row.\n4. Repeat this process for every row.\n5. Similarly, for columns with a block of \"2\"s along the right edge, if a row contains a single \"8\" in that column or immediately to the left of it, fill all cells in that row between the leftmost such \"2\" in that row and the \"8\" with \"8\", then replace the \"8\" with a \"4\".\n6. Leave all other cells unchanged; copy over cells that are not involved in these transformations as they are.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 8, 4, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 8, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0], [2, 8, 8, 8, 8, 8, 8, 4, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 8, 8, 8, 4, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "67636eac": {"instruction": "1. Identify all non-overlapping contiguous nonzero shapes (blocks) in the input grid. Each distinct shape is a cluster of adjacent (horizontally, vertically, or diagonally) nonzero cells.\n2. For each block, find the minimal rectangle (bounding box) that completely contains the block\u2019s nonzero elements.\n3. Extract the contents of each bounding box so that the resulting grid contains only the block\u2019s configuration, without extra zero padding (i.e., trim any all-zero rows/columns at the edges of the box).\n4. Preserve the relative cell values, positions, and color patterns inside the bounding box.\n5. Stack the extracted and trimmed blocks vertically in their original top-to-bottom order as found in the input grid.\n6. Ensure that there are no all-zero rows between blocks in the final output grid.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 1, 0, 1, 0], [0, 4, 4, 4, 0, 0, 2, 0, 2, 0, 3, 0, 3, 0, 1, 1, 1, 0], [0, 4, 0, 4, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[3, 0, 3],\n [3, 3, 3],\n [3, 0, 3]]\n\n[[4, 0, 4],\n [4, 4, 4],\n [4, 0, 4]]\n\n[[2, 0, 2],\n [2, 2, 2],\n [2, 0, 2]]\n\n[[1, 0, 1],\n [1, 1, 1],\n [1, 0, 1]]", "expected_output": [[4, 0, 4, 2, 0, 2, 3, 0, 3, 1, 0, 1], [4, 4, 4, 2, 2, 2, 3, 3, 3, 1, 1, 1], [4, 0, 4, 2, 0, 2, 3, 0, 3, 1, 0, 1]]}, "6773b310": {"instruction": "1. Divide the input grid into four blocks by locating the rows and columns that contain only the value 8. These rows and columns act as thick separators, splitting the grid into four approximately equal quadrants.  \n2. For each quadrant (which is a 5x5 block of cells surrounded by the separating lines of 8s), do the following:  \n\u2003a. Ignore the separating border of 8s; only consider the 5x5 inner block for each quadrant.  \n\u2003b. Within the 5x5 inner block, search for cells containing the value 6.  \n\u2003c. For each quadrant, if one or more cells in the quadrant contain the value 6, set the corresponding position in a new 3x3 output grid to 1; otherwise set it to 0. Map quadrants to output cells as:  \n\u2003\u2003- Top-left quadrant \u2192 output[0][0]  \n\u2003\u2003- Top-right quadrant \u2192 output[0][2]  \n\u2003\u2003- Bottom-left quadrant \u2192 output[2][0]  \n\u2003\u2003- Bottom-right quadrant \u2192 output[2][2]  \n\u2003d. The middle cells in the output grid (positions [0][1], [1][0], [1][1], [1][2], [2][1]) are always set to 0.  \n3. Construct the 3x3 output grid according to the results from step 2.", "test_input": [[0, 0, 0, 8, 0, 0, 0, 8, 6, 0, 6], [0, 6, 0, 8, 0, 0, 6, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 6, 0], [0, 0, 6, 8, 0, 6, 0, 8, 0, 0, 0], [0, 0, 0, 8, 6, 0, 0, 8, 0, 0, 6], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 6, 8, 0, 0, 0, 8, 0, 0, 0], [6, 0, 0, 8, 0, 0, 0, 8, 0, 6, 0], [0, 0, 0, 8, 0, 6, 0, 8, 0, 0, 0]], "predicted_output": "[[1, 0, 1],\n [0, 0, 0],\n [1, 0, 1]]", "expected_output": [[0, 0, 1], [0, 1, 1], [1, 0, 0]]}, "67a3c6ac": {"instruction": "1. For each row in the input grid, reverse the order of its elements (mirror the row horizontally).\n2. After all rows have been reversed, reverse the order of the rows themselves (mirror the grid vertically).", "test_input": [[7, 6, 1], [6, 7, 6], [6, 2, 2]], "predicted_output": "[[2, 2, 6],\n [6, 7, 6],\n [1, 6, 7]]", "expected_output": [[1, 6, 7], [6, 7, 6], [2, 2, 6]]}, "67a423a3": {"instruction": "1. Identify the vertical line of nonzero values that runs through the grid (the \"pole\"). Find the unique value forming this column; in this test input, it is the value 5, located consistently in column 8 of each row.\n2. Locate the horizontal row that intersects this vertical line and contains all nonzero values except for the pole value (here, row 6 contains a \"ring\" of 3's with the central value being 5).\n3. In this intersecting row, replace every value except for the pole value (5) with the value 4.\n4. In the rows immediately above and immediately below the intersecting row (rows 5 and 7 in this example), replace the three cells immediately to the left and right of the pole value (i.e., columns 7, 8, 9) with the value 4, centered on the pole (the pole column is column 8).\n5. In the rows two above and two below the intersecting row (rows 4 and 8 in this example), replace the cell immediately adjacent to the pole column on both sides (columns 7 and 9) with the value 4.\n6. Leave all other values in the grid unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 4, 5, 4, 0, 0],\n [0, 0, 0, 0, 0, 0, 4, 4, 5, 4, 4, 0],\n [4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 4, 4, 5, 4, 4, 0],\n [0, 0, 0, 0, 0, 0, 0, 4, 5, 4, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0], [3, 3, 3, 3, 3, 3, 3, 4, 5, 4, 3, 3], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0]]}, "67c52801": {"instruction": "1. Remove all rows above the bottom two rows and below the top block-groups of nonzero numbers, leaving only enough rows to fit the merged components and two base rows.\n2. Move each contiguous nonzero block that was previously above the base (bottom two rows) down, so that all columns are 'packed' from the bottom up with all their nonzero elements in original left-right order, with empty cells above filled with zeros.\n3. Merge all compacted nonzero blocks such that each distinct colored shape is placed directly above the matching columns in the base, preserving their relative lateral positions.\n4. For columns where the vertical merging places two or more distinctly colored blocks, keep their colors as in the input grid sequence (top to bottom) without overlap; apply background zeros elsewhere.", "test_input": [[2, 2, 0, 6, 6, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0], [2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 5, 0, 0, 5, 0, 0, 0, 0, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n [5, 0, 5, 0, 0, 5, 0, 0, 0, 0, 5],\n [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 1, 1, 0, 2, 2, 2, 2, 0], [5, 6, 5, 1, 1, 5, 2, 2, 2, 2, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]}, "67e8384a": {"instruction": "1. Take the input grid of size 3x3. Reflect the grid horizontally (left-to-right) to create a mirrored version.\n2. Concatenate this mirrored version to the right side of the original grid, resulting in a 3x6 grid: [original | mirrored].\n3. Reflect the resulting 3x6 grid vertically (top-to-bottom) to create a mirrored block of this intermediate grid.\n4. Concatenate this vertical reflection below the first 3x6 grid, resulting in a 6x6 output grid:  \n   [[original | mirrored],  \n    [vertical reflection of above]]", "test_input": [[1, 6, 6], [5, 2, 2], [2, 2, 2]], "predicted_output": "[[1, 6, 6, 6, 6, 1],\n [5, 2, 2, 2, 2, 5],\n [2, 2, 2, 2, 2, 2],\n [2, 2, 2, 2, 2, 2],\n [5, 2, 2, 2, 2, 5],\n [1, 6, 6, 6, 6, 1]]", "expected_output": [[1, 6, 6, 6, 6, 1], [5, 2, 2, 2, 2, 5], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [5, 2, 2, 2, 2, 5], [1, 6, 6, 6, 6, 1]]}, "681b3aeb": {"instruction": "1. Identify all nonzero colored cells in the input grid. These colored cells will be grouped into contiguous blocks (connected nonzero values).\n2. For each block, find the minimum bounding rectangle that contains all nonzero cells; record its top-left and bottom-right coordinates.\n3. Combine all identified nonzero cells from all blocks into a single list.\n4. Find the minimum and maximum row and column indices of all these combined nonzero cells. Use these to define a new minimal bounding rectangle that contains all nonzero cells (from all blocks).\n5. Create a new output grid whose dimensions match the size of this minimal bounding rectangle.\n6. Copy the pattern of nonzero values from the input grid, as found within this bounding rectangle, into the output grid, preserving their colors and relative positions.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 2, 2],\n [0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0],\n [0, 0, 0, 8, 8],\n [0, 0, 0, 8, 0],\n [0, 0, 0, 8, 8],\n [0, 0, 0, 0, 0]]", "expected_output": [[8, 8, 2], [8, 2, 2], [8, 8, 8]]}, "6855a6e4": {"instruction": "1. Identify all nonzero cells (cells with value 5) that are **not** located within the bounding rectangle of any area formed by 2s. (\"Bounding rectangle\" means the minimal continuous rectangle that contains all 2s in a block, including all interior 0s.)\n2. Change the value of all such out-of-bounding-rectangle 5s to 0, effectively \"removing\" these 5s from the grid.\n3. For each bounding rectangle containing any 2s (the area enclosed by each block of 2s and their surrounding 0s, if any), move all 5s that were originally contained (or partially contained) within that rectangle to the minimal block of contiguous 5s inside the rectangle, centered within the rectangle, directly occupying the original pattern if possible. Set all other cells inside the rectangle that are not 2s or these new 5s to 0.\n4. Leave all 2s untouched, and leave all cells outside the bounding rectangles of each 2-block (including other areas with only 0s) untouched.", "test_input": [[0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "689c358e": {"instruction": "1. For every cell on the borders of the grid (the first and last rows, and the first and last columns), if the cell contains the value 6, check if it is in the same row or column as any 'special' color (5, 8, 9, 2) from the main inner area. If it aligns vertically or horizontally with a cell in the inner area that contains 5, 8, 9, or 2, replace it as follows:\n    - If aligned with a 5, set it to 5.\n    - If aligned with an 8, set it to 8.\n    - If aligned with a 9, set it to 9.\n    - If aligned with a 2, set it to 2.\n    - If the same border position is aligned with multiple special values, use the one nearest to the border along that line of sight.\n2. For every border cell where no special color is aligned in its row or column (i.e., no visible 5, 8, 9, 2 between border and inner area), change it to 0 if it shares row or column with a row/column that was modified in step 1.\n3. Leave all non-border (inner area) cells unchanged.", "test_input": [[6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6], [6, 7, 5, 7, 7, 7, 7, 7, 7, 7, 6], [6, 5, 5, 5, 7, 7, 2, 7, 7, 7, 6], [6, 7, 5, 7, 7, 2, 2, 2, 7, 7, 6], [6, 7, 5, 7, 7, 7, 2, 7, 9, 7, 6], [6, 7, 7, 7, 7, 7, 2, 7, 9, 7, 6], [6, 7, 7, 7, 8, 7, 7, 9, 9, 9, 6], [6, 7, 7, 8, 8, 8, 8, 7, 9, 7, 6], [6, 7, 7, 7, 8, 7, 7, 7, 7, 7, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]], "predicted_output": "[[5, 5, 5, 8, 8, 8, 8, 9, 9, 9, 9],\n [5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 9],\n [5, 7, 5, 7, 7, 7, 7, 7, 7, 7, 9],\n [5, 5, 5, 5, 7, 7, 2, 7, 7, 7, 9],\n [2, 7, 5, 7, 7, 2, 2, 2, 7, 7, 9],\n [2, 7, 5, 7, 7, 7, 2, 7, 9, 7, 8],\n [2, 7, 7, 7, 7, 7, 2, 7, 9, 7, 8],\n [2, 7, 7, 7, 8, 7, 7, 9, 9, 9, 8],\n [2, 7, 7, 8, 8, 8, 8, 7, 9, 7, 8],\n [0, 7, 7, 7, 8, 7, 7, 7, 7, 7, 8],\n [0, 0, 5, 8, 8, 8, 8, 9, 9, 9, 9]]", "expected_output": [[6, 6, 5, 6, 6, 6, 2, 6, 0, 6, 6], [6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6], [6, 7, 5, 7, 7, 7, 7, 7, 7, 7, 6], [6, 5, 5, 5, 7, 7, 2, 7, 7, 7, 6], [6, 7, 5, 7, 7, 2, 2, 2, 7, 7, 6], [6, 7, 5, 7, 7, 7, 2, 7, 9, 7, 6], [6, 7, 7, 7, 7, 7, 2, 7, 9, 7, 6], [6, 7, 7, 7, 8, 7, 7, 9, 9, 9, 6], [8, 7, 7, 8, 8, 8, 8, 7, 9, 7, 0], [6, 7, 7, 7, 8, 7, 7, 7, 7, 7, 6], [6, 6, 0, 6, 6, 6, 0, 6, 9, 6, 6]]}, "68b16354": {"instruction": "1. Reverse the order of the rows in the input grid. That is, take the last row and make it the first row, the second-to-last row becomes the second row, and so on, until the original first row is now the last row.", "test_input": [[2, 8, 1, 3, 2, 4, 1], [4, 4, 1, 1, 4, 3, 4], [1, 1, 1, 1, 4, 7, 3], [1, 1, 2, 3, 8, 1, 3], [4, 1, 1, 1, 7, 8, 4], [3, 2, 8, 4, 1, 8, 4], [1, 4, 7, 1, 2, 3, 4]], "predicted_output": "[[1, 4, 7, 1, 2, 3, 4],\n [3, 2, 8, 4, 1, 8, 4],\n [4, 1, 1, 1, 7, 8, 4],\n [1, 1, 2, 3, 8, 1, 3],\n [1, 1, 1, 1, 4, 7, 3],\n [4, 4, 1, 1, 4, 3, 4],\n [2, 8, 1, 3, 2, 4, 1]]", "expected_output": [[1, 4, 7, 1, 2, 3, 4], [3, 2, 8, 4, 1, 8, 4], [4, 1, 1, 1, 7, 8, 4], [1, 1, 2, 3, 8, 1, 3], [1, 1, 1, 1, 4, 7, 3], [4, 4, 1, 1, 4, 3, 4], [2, 8, 1, 3, 2, 4, 1]]}, "68b67ca3": {"instruction": "1. Identify all non-empty rows of the input grid. A non-empty row is a row that contains at least one non-zero element.\n2. From these non-empty rows, extract only the columns that contain at least one non-zero element across any of the non-empty rows. Discard columns that are entirely zero in all non-empty rows.\n3. The resulting grid, composed of the selected non-empty rows and columns, is the output grid.", "test_input": [[3, 0, 3, 0, 4, 0], [0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0]], "predicted_output": "[[3, 0, 3, 0, 4, 0],\n [7, 0, 0, 0, 1, 0],\n [7, 0, 0, 0, 1, 0]]", "expected_output": [[3, 3, 4], [7, 0, 1], [7, 0, 1]]}, "68bc2e87": {"instruction": "1. Scan the entire input grid and collect all unique colors (cell values) except for the background color (which is 8).\n2. Sort the collected unique colors in ascending order.\n3. Construct the output grid as a single column, where each row contains one of the sorted unique colors from step 2.", "test_input": [[8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8], [8, 1, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 4, 4, 4, 8, 8], [8, 1, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 4, 8, 8], [8, 1, 8, 4, 8, 8, 6, 6, 6, 6, 6, 8, 8, 1, 8, 8, 4, 8, 8], [8, 1, 8, 4, 8, 8, 6, 8, 8, 8, 6, 8, 8, 1, 8, 8, 4, 8, 8], [8, 1, 1, 1, 1, 1, 6, 1, 1, 1, 6, 1, 1, 1, 8, 8, 4, 8, 8], [8, 8, 8, 4, 8, 8, 6, 8, 8, 8, 6, 8, 8, 8, 8, 8, 4, 8, 8], [8, 2, 2, 4, 2, 2, 6, 2, 2, 2, 6, 2, 2, 2, 2, 2, 4, 2, 8], [8, 2, 8, 4, 8, 8, 6, 8, 8, 8, 6, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 8, 4, 8, 5, 5, 5, 6, 6, 6, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 8, 4, 8, 5, 5, 5, 8, 8, 8, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 2, 8], [8, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 8], [8, 8, 8, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8], [8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "predicted_output": "[[1],\n [2],\n [4],\n [5],\n [6]]", "expected_output": [[2], [4], [1], [6], [5]]}, "692cd3b6": {"instruction": "1. Identify all solid \"cross\" shapes in the grid, defined as a center cell with color 5 that is surrounded directly up, down, left, and right by cells of color 2. There may be one or more such crosses in the grid.\n2. For each detected cross, do the following:\n   a. Replace any cell with value 0 **immediately to the right** of the central cell (5) with the value 4, and do the same for the next cell to the right, if applicable. Repeat this to fill to the right edge as long as the original was 0 (not 2/5).\n   b. Starting from the row below the bottom 2 of the cross, and for each row until just before the next non-empty row or the edge of the grid, replace all cells directly **below** the right \u201carm\u201d of the cross (i.e., under the 2\u2019s and any filled 4\u2019s from step 2a) with the value 4, stopping at the first non-0 or grid boundary. For all these rows, also fill all cells to the right from the first filled column, as long as they were 0.\n   c. For each row of the right arm of the cross (the horizontal 2s), convert all 0s to the right of the cross (to the right of the last 2 or of the 5) into 4, up to the grid edge or nonzero cell.\n   d. In the center row of the cross, if the rightmost 2 is immediately followed by 0s, turn the first 0 into 4, and next 0 into 4, etc., as in step c.\n3. Keep all other elements unchanged (do not affect any 2s or 5s, or any other existing non-0 values).", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 4, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 4, 4, 4],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 2, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 5, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 2, 2, 2, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 5, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "694f12f3": {"instruction": "1. Identify each contiguous rectangular block of nonzero (color 4) cells in the grid, treating rows separated by all-0 rows as separate blocks.\n2. For each block, determine the dimensions (height and width).\n3. If the width and height of the block are greater than or equal to 4, replace the 3x3 area in the center of the block as follows:\n    a. For the upper or left block, change the inner 3x3 area located starting from the second row/column (i.e., excluding the boundary of the block) to color 2 if the block is located in the lower part of the grid, or to color 1 if the block is located in the upper part of the grid. \n    b. If there is ambiguity, use the same top/bottom assignment as seen in the prior examples (top gets color 2, bottom gets color 1, or vice versa).\n4. All other cells remain unchanged.", "test_input": [[4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4]], "predicted_output": "[[4, 4, 4, 4, 4, 4, 0, 0, 0, 0],\n [4, 1, 1, 1, 1, 4, 0, 0, 0, 0],\n [4, 1, 1, 1, 1, 4, 0, 0, 0, 0],\n [4, 1, 1, 1, 1, 4, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 0, 0, 0, 0],\n [4, 4, 4, 4, 4, 4, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 4, 2, 2, 2, 4, 4],\n [0, 0, 0, 0, 4, 2, 2, 2, 4, 4],\n [0, 0, 0, 0, 4, 2, 2, 2, 4, 4]]", "expected_output": [[4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 1, 1, 1, 1, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4]]}, "695367ec": {"instruction": "1. Let the input grid be of size N\u00d7N (for N\u22651), and let the constant value in the grid be C.\n2. Create an output grid of size (2N+1)\u00d7(3N) (i.e., rows = 2N+1, columns = 3N).\n3. Fill the output grid with 0s initially.\n4. For each input row i (0 \u2264 i < N), do the following:\n    a. For rows i and (i+N+1) in the output grid, and for each column j (0 \u2264 j < N), set the value at columns (3j+N) in these rows to C.\n        - That is, output[i][3j+N] = C and output[i+N+1][3j+N] = C.\n5. For row N in the output grid, fill all columns (from 0 to 3N-1) with C.\n    - That is, output[N][k] = C for all 0 \u2264 k < 3N.", "test_input": [[4, 4, 4, 4, 4], [4, 4, 4, 4, 4], [4, 4, 4, 4, 4], [4, 4, 4, 4, 4], [4, 4, 4, 4, 4]], "predicted_output": "[[0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4],\n [0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 4]]", "expected_output": [[0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0]]}, "696d4842": {"instruction": "1. Identify each \"T\"-shaped pattern in the input grid, made of contiguous nonzero cells forming a central vertical stalk and a horizontal bar at its top or bottom, and note the color used (e.g., 2, 3, 4, etc.).\n2. For each \"T\"-shaped pattern:\n    a. Replace every cell in the vertical part of the \"T\" with the color that would be used for another \"T\"-shape in the next phase (cycling through the colors, according to the sample mapping: 2\u21924, 4\u21926, 6\u21928, 3\u21922, 8\u21923).\n    b. Replace every cell in the horizontal part of the \"T\" with the color that would come before the vertical color in the cycle (for example, if the vertical is now 4, make the bar 2; if the vertical is 2, make the bar 3, etc.).\n3. Leave all other grid cells unchanged.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, "69889d6e": {"instruction": "1. Identify all cells in the grid with the value \"2\". Record their coordinates. These are the starting points for the spiral.\n2. Starting from each \"2\" cell, fill in a counterclockwise spiral path with the value \"2\", expanding layer by layer. \n   - For each new layer, move right, then up, then left, then down, and repeat, forming a counterclockwise outward pattern.\n   - At each step, place a \"2\" in empty (zero-valued) cells along the spiral path until you reach the grid boundary or an already-filled nonzero cell.\n3. If there are any nonzero, non-\"2\" cells in the grid (such as \"1\"s), leave their positions and values unchanged.\n4. Continue the spiral until no more eligible positions can be filled along the path.", "test_input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], "predicted_output": "[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [0, 2, 0, 0, 0, 0, 0, 0, 0, 0]]", "expected_output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 1, 2, 2], [0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [0, 0, 0, 1, 1, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0]]}, "6a11f6da": {"instruction": "1. Divide the input grid vertically into 3 equal sections of 5 rows each. The top 5 rows are the \"Shape Section,\" the next 5 rows the \"8 Section,\" and the last 5 rows the \"6 Section.\"\n2. Initialize an empty 5x5 output grid.\n3. For each cell (i, j) in the 5x5 grid:\n    a. If the corresponding cell in the \"Shape Section\" is 1, set output[i][j] = 1.\n    b. If the corresponding cell in the \"Shape Section\" is 0, proceed:\n        i. If the corresponding cell in the \"8 Section\" is 8, set output[i][j] = 8.\n        ii. Else if the corresponding cell in the \"6 Section\" is 6, set output[i][j] = 6.\n        iii. Else, set output[i][j] = 0.", "test_input": [[1, 0, 1, 1, 1], [1, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 1, 1, 0], [1, 0, 1, 0, 1], [0, 0, 8, 0, 0], [0, 0, 8, 8, 8], [8, 8, 0, 8, 8], [0, 0, 8, 0, 0], [8, 8, 0, 8, 0], [0, 6, 0, 6, 0], [0, 0, 6, 0, 6], [0, 6, 0, 0, 6], [0, 0, 6, 0, 6], [6, 0, 6, 6, 0]], "predicted_output": "[[1, 0, 1, 1, 1],\n [1, 0, 1, 0, 0],\n [0, 1, 1, 0, 0],\n [0, 1, 1, 1, 0],\n [1, 0, 1, 0, 1]]", "expected_output": [[1, 6, 1, 6, 1], [1, 0, 6, 8, 6], [8, 6, 1, 8, 6], [0, 1, 6, 1, 6], [6, 8, 6, 6, 1]]}, "6a1e5592": {"instruction": "1. For each cell in the grid, replace all instances of the color 5 with 1.\n2. Starting from the top row, for every column and row, process as follows:\n   a. For every contiguous group of cells filled with 1s (originally 5s) that is connected to an original 0 cell anywhere above it (including diagonally), retain the 1s.\n   b. For groups of 1s (originally 5s) that are not connected to any 0 above them (i.e., they are \"floating\" and not supported), change them to 0.\n3. All other cells (those not modified in step 1 or 2) remain unchanged from input.", "test_input": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2], [2, 0, 0, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 5, 0], [0, 5, 0, 0, 0, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 0, 0, 0, 5, 0, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0]], "predicted_output": "[[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [2, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2],\n [2, 0, 0, 2, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 2],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0],\n [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\n [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0],\n [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0]]", "expected_output": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 1, 2, 2, 2, 2, 1, 2, 1, 2, 2, 1, 2, 2, 2], [2, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}}